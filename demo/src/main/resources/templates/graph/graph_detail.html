
                <!DOCTYPE html>
                <html lang="zh">
                <head>
                  <meta charset="UTF-8">
                  <meta name="viewport" content="width=device-width, initial-scale=1.0">
                  <title>图谱详情页</title>
                  <style>
                    *,
                    *::before,
                    *::after {
                      box-sizing: border-box;
                      margin: 0;
                    }
                    .iframe-outer {
                      position: fixed;
                      top: 0;
                      left: 0;
                      bottom: 0;
                      right: 0;
                      display: flex;
                      justify-content: center;
                      background-color: #E0E0E0;
                    }
                    .iframe-wrapper {
                      width: 100%;
                      height: 100%;
                      margin: 0 auto;
                      transform-origin: center top;
                      flex-shrink: 0;
                    }
                    #dynamicIframe {
                      border: none;
                      width: 100%;
                      height: 100%;
                    }
                  </style>
                  <script>
                const width = 1920
                const height = 1080
                const resolutionRatio = width && height ? width / height : 1
                const pageNameMap = {
                  'home_page': '首页',
    'login_register_page': '登录注册',
    'registration_success_page': '注册成功',
    'password_reset_page': '找回密码',
    'graph_list_page': '图谱列表页',
    'graph_detail_page': '图谱详情页',
    'user_profile_page': '个人中心',
    'documentation_page': '文档',
    'about_page': '关于我们',
    'feedback_page': '用户反馈',
    'page_998124': '管理',
    'page_998125': '论坛'
                }
                function setIframeSize(w, h) {
                  const currentContainerRadio = w / h
                  let widthValue = w
                  let heightValue = h
                  let zoom = 1
                  if (currentContainerRadio > resolutionRatio) {
                    widthValue = h * resolutionRatio
                    heightValue = h
                  } else {
                    widthValue = w
                    heightValue = w / resolutionRatio
                  }
                  zoom = width ? widthValue / width : 1
                  return {
                    width: widthValue / zoom + 'px',
                    height: heightValue / zoom + 'px',
                    zoom,
                  }
                }
                function adjustIframeSize() {
                  const iframeWrapper = document.querySelector(".iframe-wrapper")
                  if (!iframeWrapper) return
                  iframeWrapper.style.width = '100%'
                  iframeWrapper.style.height = window.innerHeight + 'px'
                  iframeWrapper.style.transform = ''
                }
                function sanitizeFilename(name) {
                  return name.replace(/[\/:*?"<>|]/g, '_')
                }
                function handlePostMessage(event) {
                  if (!event.data) {
                    return
                  }
                  const { type, targetPageId, params } = event.data
                  const pagePathMap = {
                    'home_page': './home.html',
                    'login_register_page': '../user/login_register.html',
                    'registration_success_page': '../user/registration_success.html',
                    'password_reset_page': '../user/password_reset.html',
                    'graph_list_page': './graph_list.html',
                    'graph_detail_page': './graph_detail.html',
                    'user_profile_page': '../user/profile.html',
                    'documentation_page': '../pages/documentation.html',
                    'about_page': '../pages/about.html',
                    'feedback_page': '../community/feedback.html',
                    'page_998124': '../admin/dashboard.html',
                    'page_998125': '../community/forum_list.html'
                  };
                  let targetPath = pagePathMap[targetPageId];
                  if (type === "iframeNavigation" && targetPath) {
                    // 如果有 params，拼接到 URL 上
                    if (params && params.graphId) {
                      targetPath += '?id=' + params.graphId;
                    }
                    window.location.href = targetPath
                  }
                }
                window.addEventListener('message', handlePostMessage)
                window.onload = adjustIframeSize
                window.onresize = adjustIframeSize
                window.onunload = () => {
                  window.removeEventListener('message', handlePostMessage)
                }
              </script>
                </head>
                <body>
                  <div class="iframe-outer">
                    <div class="iframe-wrapper">
                      <iframe id="dynamicIframe" srcdoc='<html lang="zh-CN" data-theme="corporate"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>图谱详情 - Graph+知识图谱平台</title>
    <link href="/assets/static/libs/daisyui@5.css" rel="stylesheet" type="text/css">
    <script src="/assets/static/libs/tailwind-browser@4.js"></script>
    <link href="/assets/static/libs/daisyui-themes.css" rel="stylesheet" type="text/css">
    <script src="/assets/3/3.1.1/iconify.min.js"></script>
    <style>
/* daisyUI Theme Variables Customization
* Based on the selected daisyUI theme and UI guidance requirements,
* customize only the CSS variables that need to be different from the theme defaults.
*/
:root {
/* Corporate theme customization for knowledge graph platform */
--color-primary: rgba(30, 58, 138, 1); /* Deep Blue #1E3A8A - 学院风深蓝 */
--color-primary-content: rgba(255, 255, 255, 1);
--color-secondary: rgba(37, 99, 235, 1); /* Medium Blue #2563EB */
--color-secondary-content: rgba(255, 255, 255, 1);
--color-accent: rgba(16, 185, 129, 1); /* Emerald Green #10B981 */
--color-accent-content: rgba(255, 255, 255, 1);
--color-base-100: rgba(255, 255, 255, 1);
--color-base-200: rgba(247, 249, 250, 1); /* #F7F9FA */
--color-base-300: rgba(229, 231, 235, 1); /* #E5E7EB */
--color-base-content: rgba(55, 65, 81, 1); /* #374151 */
--color-success: rgba(16, 185, 129, 1);
--color-warning: rgba(245, 158, 11, 1);
--color-error: rgba(239, 68, 68, 1);
--color-info: rgba(59, 130, 246, 1);
--radius-box: 0.375rem; /* 6px for micro-rounded corners */
--radius-field: 0.375rem;
--border: 1px;
}

/* Global component styles */
.transition-width {
transition: width 0.3s ease-in-out;
}

.nav-hover {
transition: background-color 0.15s ease-in-out, color 0.15s ease-in-out;
}

.shadow-soft {
box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1);
}

/* Header height consistency */
.header-height {
height: 64px;
}

/* Focus styles for accessibility */
.focus-primary:focus {
outline: 2px solid var(--color-primary);
outline-offset: 2px;
}

/* Academic style enhancements */
.academic-border {
border: var(--border) solid var(--color-base-300);
}

.hover-lift {
transition: transform 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
}

.hover-lift:hover {
transform: translateY(-2px);
box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

/* Professional grid spacing */
.academic-grid {
gap: 1.5rem;
}

/* Clean divider lines */
.academic-divider {
border-color: var(--color-base-300);
border-width: var(--border);
}
</style> <style>
/* Graph Detail Page Specific Styles */
.line-clamp-2 {
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
}

/* ==================== 可调整侧边栏样式 ==================== */

/* 左侧边栏 */
#leftSidebar {
    width: 280px;
    min-width: 200px;
    max-width: 400px;
    transition: width 0.3s ease, margin-left 0.3s ease;
    position: relative;
    overflow: hidden;
}

#leftSidebar.collapsed {
    width: 0 !important;
    min-width: 0;
    margin-left: -1px;
    overflow: hidden;
}

#leftSidebar.collapsed .sidebar-content {
    opacity: 0;
    pointer-events: none;
}

/* 右侧详情栏 */
#rightSidebar {
    width: 300px;
    min-width: 220px;
    max-width: 450px;
    transition: width 0.3s ease, margin-right 0.3s ease;
    position: relative;
    overflow: hidden;
}

#rightSidebar.collapsed {
    width: 0 !important;
    min-width: 0;
    margin-right: -1px;
    overflow: hidden;
}

#rightSidebar.collapsed .sidebar-content {
    opacity: 0;
    pointer-events: none;
}

/* 侧边栏内容容器 */
.sidebar-content {
    transition: opacity 0.2s ease;
    height: 100%;
    overflow-y: auto;
}


/* 拖拽调整手柄 */
.resize-handle {
    position: absolute;
    top: 0;
    width: 6px;
    height: 100%;
    cursor: col-resize;
    background: transparent;
    z-index: 100;
    transition: background-color 0.2s;
}

.resize-handle:hover,
.resize-handle.active {
    background: linear-gradient(to right, transparent, rgba(59, 130, 246, 0.3), transparent);
}

.resize-handle-left {
    right: -3px;
}

.resize-handle-right {
    left: -3px;
}

/* 收起/展开按钮 */
.sidebar-toggle {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    width: 20px;
    height: 48px;
    background: var(--color-base-200);
    border: 1px solid var(--color-base-300);
    border-radius: 0 6px 6px 0;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 101;
    transition: all 0.2s;
}

.sidebar-toggle:hover {
    background: var(--color-base-300);
}

.sidebar-toggle-left {
    right: -20px;
    border-left: none;
}

.sidebar-toggle-right {
    left: -20px;
    border-radius: 6px 0 0 6px;
    border-right: none;
}

.sidebar-toggle .iconify {
    transition: transform 0.3s;
}

.collapsed .sidebar-toggle-left .iconify {
    transform: rotate(180deg);
}

.collapsed .sidebar-toggle-right .iconify {
    transform: rotate(180deg);
}

/* Graph canvas styles with subtle grid background */
#graphCanvas {
    background: linear-gradient(45deg, rgba(229, 231, 235, 0.15) 25%, transparent 25%),
                linear-gradient(-45deg, rgba(229, 231, 235, 0.15) 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, rgba(229, 231, 235, 0.15) 75%),
                linear-gradient(-45deg, transparent 75%, rgba(229, 231, 235, 0.15) 75%);
    background-size: 24px 24px;
    background-position: 0 0, 0 12px, 12px -12px, -12px 0px;
}

/* Node details card styling */
.node-detail-card {
    background: var(--color-base-100);
    border: var(--border) solid var(--color-base-300);
    border-radius: var(--radius-box);
    padding: 1.5rem;
    transition: all 0.15s ease-in-out;
}

.node-detail-card:hover {
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
}

/* Graph node styles */
.graph-node {
    cursor: pointer;
    transition: all 0.2s ease-in-out;
}

.graph-node:hover {
    transform: scale(1.1);
    filter: brightness(1.1);
}

.graph-node.selected {
    stroke: var(--color-primary);
    stroke-width: 3px;
    filter: drop-shadow(0 2px 4px rgba(30, 58, 138, 0.3));
}

.graph-edge {
    stroke: var(--color-base-content);
    stroke-opacity: 0.5;
    stroke-width: 1.5px;
    transition: all 0.2s ease-in-out;
}

.graph-edge.highlighted {
    stroke: var(--color-accent);
    stroke-opacity: 0.8;
    stroke-width: 2.5px;
}

/* Statistics section collapsible */
.statistics-collapsed #statisticsContent {
    display: none;
}

/* Enhanced range slider styling for academic look */
.range {
    height: 0.375rem;
    background: var(--color-base-300);
    border-radius: var(--radius-field);
}

.range::-webkit-slider-thumb {
    height: 1.125rem;
    width: 1.125rem;
    border-radius: 50%;
    background: var(--color-primary);
    cursor: pointer;
    border: 2px solid var(--color-base-100);
    box-shadow: 0 2px 6px rgba(30, 58, 138, 0.2);
    transition: all 0.15s ease-in-out;
}

.range::-webkit-slider-thumb:hover {
    transform: scale(1.1);
    box-shadow: 0 3px 8px rgba(30, 58, 138, 0.3);
}

.range::-moz-range-thumb {
    height: 1.125rem;
    width: 1.125rem;
    border-radius: 50%;
    background: var(--color-primary);
    cursor: pointer;
    border: 2px solid var(--color-base-100);
    box-shadow: 0 2px 6px rgba(30, 58, 138, 0.2);
    transition: all 0.15s ease-in-out;
}

/* Checkbox styling enhancements for academic look */
.checkbox {
    border: var(--border) solid var(--color-base-300);
    border-radius: var(--radius-selector);
}

.checkbox:checked {
    background-color: var(--color-primary);
    border-color: var(--color-primary);
}

.checkbox-secondary:checked {
    background-color: var(--color-secondary);
    border-color: var(--color-secondary);
}

/* Recommendation scroll styling */
#recommendationsContainer::-webkit-scrollbar {
    height: 8px;
}

#recommendationsContainer::-webkit-scrollbar-track {
    background: var(--color-base-300);
    border-radius: 4px;
}

#recommendationsContainer::-webkit-scrollbar-thumb {
    background: var(--color-primary);
    border-radius: 4px;
}

#recommendationsContainer::-webkit-scrollbar-thumb:hover {
    background: var(--color-secondary);
}

/* Favorite button active state */
.favorite-active {
    color: var(--color-error) !important;
}

/* Search highlight */
.search-highlight {
    background-color: rgba(245, 158, 11, 0.25);
    border-radius: var(--radius-selector);
    padding: 1px 3px;
}

/* Loading overlay */
.graph-loading-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(255, 255, 255, 0.95);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10;
    backdrop-filter: blur(2px);
}

/* Tooltip customization for graph elements */
.graph-tooltip {
    position: absolute;
    background: var(--color-base-100);
    border: var(--border) solid var(--color-base-300);
    border-radius: var(--radius-box);
    padding: 0.75rem;
    font-size: 0.875rem;
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.12);
    z-index: 1000;
    pointer-events: none;
    max-width: 240px;
}

/* Statistics cards styling */
.stat {
    border-radius: var(--radius-box);
    border: var(--border) solid var(--color-base-300);
    transition: all 0.15s ease-in-out;
}

.stat:hover {
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
}

/* Enhanced button styling for academic look */
.btn {
    border-radius: var(--radius-field);
    transition: all 0.15s ease-in-out;
    border: var(--border) solid transparent;
}

.btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
}

.btn-circle {
    border-radius: 50%;
}

/* Select dropdown styling */
.select {
    border-radius: var(--radius-field);
    border: var(--border) solid var(--color-base-300);
}

/* Input field styling */
.input {
    border-radius: var(--radius-field);
    border: var(--border) solid var(--color-base-300);
}

/* Card styling enhancements */
.card {
    border-radius: var(--radius-box);
    border: var(--border) solid var(--color-base-300);
}

/* Badge styling */
.badge {
    border-radius: var(--radius-selector);
    border: var(--border) solid transparent;
}

.badge-outline {
    border-color: var(--color-base-300);
}

/* Chart container styling */
#chartContainer {
    border: var(--border) solid var(--color-base-300);
    border-radius: var(--radius-box);
    transition: all 0.15s ease-in-out;
}

#chartContainer:hover {
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
}

/* Dropdown styling for chart selection */
.dropdown-content {
    border: var(--border) solid var(--color-base-300);
    border-radius: var(--radius-box);
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12);
}

.dropdown-content a {
    transition: all 0.15s ease-in-out;
    border-radius: var(--radius-selector);
    margin: 2px;
}

.dropdown-content a:hover {
    background-color: var(--color-base-200);
    transform: translateX(2px);
}

.dropdown-content a.active {
    background-color: var(--color-primary) !important;
    color: var(--color-primary-content) !important;
    font-weight: 500;
}

.dropdown-content a.active:hover {
    background-color: var(--color-primary) !important;
    transform: none;
}

/* Chart container loading animation */
.chartContainer {
    transition: all 0.3s ease-in-out;
}

.chartContainer img {
    transition: opacity 0.3s ease-in-out;
}

/* Enhanced loading spinner for charts */
.loading.loading-spinner.loading-lg {
    width: 3rem;
    height: 3rem;
}

/* Responsive adjustments */
@media (max-width: 1280px) {
    .w-80 {
        width: 18rem;
    }
    
    .w-16 {
        width: 3.5rem;
    }
    
    .grid-cols-4 {
        grid-template-columns: repeat(2, minmax(0, 1fr));
    }
}

@media (max-width: 1024px) {
    .w-80 {
        width: 16rem;
    }
    
    .grid-cols-4 {
        grid-template-columns: 1fr;
    }
}

@media (max-width: 768px) {
    /* Stack the three main columns vertically */
    .flex-1.flex { flex-direction: column; }
    .w-80 { width: 100%; }
    .w-16 { display: none; }
    #graphVisualizationArea { min-height: 50vh; }
    .p-6 { padding: 1rem; }
}

/* Extra small screens */
@media (max-width: 640px) {
    .header-height { height: 56px; }
    .btn.btn-sm { height: 2.5rem; }
    .join .input { height: 3rem; }
    .join .btn { height: 3rem; }
}

/* Smooth transitions for interactive elements */
.checkbox,
.range,
.select,
.input {
    transition: all 0.15s ease-in-out;
}

/* Focus states for accessibility */
.checkbox:focus,
.range:focus,
.select:focus,
.input:focus {
    outline: 2px solid var(--color-primary);
    outline-offset: 2px;
}

/* Modal styling enhancements */
.modal-box {
    border-radius: var(--radius-box);
    border: var(--border) solid var(--color-base-300);
    box-shadow: 0 16px 48px rgba(0, 0, 0, 0.15);
}

.modal-backdrop {
    background-color: rgba(0, 0, 0, 0.4);
    backdrop-filter: blur(2px);
}

/* Copy button animation */
.btn.btn-success {
    background-color: var(--color-success);
    border-color: var(--color-success);
    color: white;
}

/* Join input styling */
.join .input {
    border-right: none;
}

.join .btn {
    border-left: none;
}

/* Download format buttons */
.btn-outline:hover {
    transform: translateY(-1px);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
}

/* Modal close button styling */
.modal-box .btn-circle {
    background-color: var(--color-base-200);
    border: var(--border) solid var(--color-base-300);
}

.modal-box .btn-circle:hover {
    background-color: var(--color-base-300);
}

/* Academic spacing enhancements */
.space-y-3 > * + * {
    margin-top: 0.75rem;
}

.space-y-4 > * + * {
    margin-top: 1rem;
}

.space-y-6 > * + * {
    margin-top: 1.5rem;
}

/* Professional typography */
.label-text {
    font-weight: 500;
    color: var(--color-base-content);
}

.stat-title {
    font-weight: 500;
    color: var(--color-base-content);
    opacity: 0.8;
}

.stat-value {
    font-weight: 600;
}

/* Enhanced academic borders */
.academic-border {
    border-color: var(--color-base-300);
}

/* Subtle hover effects for academic feel */
.hover-lift:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
}

/* Clean dividers */
.divider {
    border-color: var(--color-base-300);
}
</style>
  <script src="/assets/static/libs/25_6/holder.js"></script></head>
  <body class="bg-base-100 min-h-screen">
    <div class="header-wrapper"></div>
    <!-- Main Content -->
    <div id="i9njq" class="flex-1 flex flex-col" style="min-height: calc(100vh - 64px);">
      <!-- Graph Detail Layout -->
      <div class="flex-1 flex">
        <!-- Left Sidebar -->
        <div id="leftSidebar" class="bg-base-200 border-r academic-border flex flex-col" style="width: 320px;">
          <!-- Return Button -->
          <div class="p-6 border-b academic-border">
            <button class="btn btn-ghost btn-sm w-full justify-start gap-2 focus-primary" onclick="navigateTo(&#39;graph_list_page&#39;)">
              <span class="iconify text-base-content" data-icon="heroicons:arrow-left" data-width="16"></span>
              返回图谱列表
            </button>
          </div>
          <!-- Graph Info -->
          <div class="p-6 border-b academic-border">
            <h1 id="graphTitle" class="text-lg font-semibold text-base-content mb-3">
              加载中...
            </h1>
            <p id="graphDescription" class="text-sm text-base-content/70 mb-4 leading-relaxed">
              正在加载图谱信息...
            </p>
            <div id="graphTags" class="flex flex-wrap gap-2">
              <div class="badge badge-ghost badge-sm">加载中...</div>
            </div>
          </div>
          <!-- Search in Graph (with Advanced Search integrated) -->
          <div class="p-6 border-b academic-border">
            <div class="label">
                <span class="label-text text-sm font-medium">图谱内搜索</span>
              </div>
            <div class="space-y-3">
              <div class="join w-full">
                <select id="searchTargetSelect" class="select select-bordered select-sm join-item w-20" onchange="updateSearchPlaceholder()">
                  <option value="node">节点</option>
                  <option value="relation">关系</option>
                </select>
                <input type="text" placeholder="搜索节点名称..." id="graphSearchInput" class="input input-bordered input-sm join-item flex-1 focus-primary">
                <button class="btn btn-primary btn-sm join-item" onclick="searchInGraph()">
                  <span class="iconify" data-icon="heroicons:magnifying-glass" data-width="16"></span>
                </button>
              </div>
              <div class="form-control">
                <label class="label py-1"><span class="label-text text-xs">筛选与排序</span></label>
                <select id="searchTypeFilter" class="select select-bordered select-sm" onchange="handleFilterSort(this.value)">
                  <option value="">全部类型</option>
                  <optgroup label="排序方式">
                    <option value="sort_degree">按度数排序</option>
                  </optgroup>
                </select>
              </div>
              <div class="form-control">
                <label class="label py-1"><span class="label-text text-xs">路径查询</span></label>
                <select id="pathQuerySelect" class="select select-bordered select-sm" onchange="handlePathQuery(this.value)">
                  <option value="">选择查询方式</option>
                  <option value="relation">关系寻路</option>
                  <option value="shortest">最短路径</option>
                </select>
              </div>
              <div class="form-control">
                <label class="label py-1"><span class="label-text text-xs">邻居深度</span></label>
                <input type="range" min="1" max="5" value="2" id="depthRange" class="range range-secondary range-sm">
                <div class="w-full flex justify-between text-xs px-2 text-base-content/60">
                  <span>1</span><span>3</span><span>5</span>
                </div>
              </div>
              <div class="form-control">
                <label class="label py-1"><span class="label-text text-xs">邻居方向</span></label>
                <select id="neighborDirectionSelect" class="select select-bordered select-sm" onchange="handleNeighborDirectionChange()">
                  <option value="all">所有邻居</option>
                  <option value="out">出边邻居</option>
                  <option value="in">入边邻居</option>
                </select>
              </div>
              <!-- Search Results -->
              <div id="searchResultsPanel" class="hidden">
                <div class="flex items-center justify-between mb-2">
                  <span class="text-xs text-base-content/60">搜索结果 (<span id="searchResultCount">0</span>)</span>
                  <button class="btn btn-ghost btn-xs" onclick="resetGraphView()" title="恢复完整视图">
                    <span class="iconify" data-icon="heroicons:arrow-path" data-width="12"></span>
                    恢复
                  </button>
                </div>
                <div id="searchResultList" class="max-h-40 overflow-y-auto space-y-1 bg-base-100 rounded-lg p-2 border academic-border">
                </div>
              </div>
            </div>
          </div>
          <!-- Entity Types -->
          <div class="p-6 border-b academic-border">
            <div class="label">
              <span class="label-text text-sm font-medium">实体类型</span>
            </div>
            <div id="entityTypeFilters" class="space-y-3">
              <div class="text-sm text-base-content/50">加载中...</div>
            </div>
          </div>
          <!-- Relationship Types -->
          <div class="p-6 border-b academic-border">
            <div class="label">
              <span class="label-text text-sm font-medium">关系类型</span>
            </div>
            <div id="relationTypeFilters" class="space-y-3">
              <div class="text-sm text-base-content/50">加载中...</div>
            </div>
          </div>
          <!-- Node Management (Collapsible, Auth Required) -->
          <div id="nodeManagementSection" class="border-b academic-border" style="display: none;">
            <div class="collapse collapse-arrow bg-base-200">
              <input type="checkbox" id="nodeManagementToggle">
              <div class="collapse-title text-sm font-medium flex items-center gap-2 py-4 px-6">
                <span class="iconify text-primary" data-icon="heroicons:cog-6-tooth" data-width="16"></span>
                图谱编辑
            </div>
              <div class="collapse-content px-6 pb-4">
                <div class="space-y-2">
                  <div class="text-xs text-base-content/60 mb-3">节点操作</div>
                  <button class="btn btn-outline btn-sm w-full justify-start gap-2" onclick="openBatchImportModal()">
                    <span class="iconify" data-icon="heroicons:arrow-up-tray" data-width="16"></span>
                    导入节点
                  </button>
                  <button class="btn btn-outline btn-sm w-full justify-start gap-2" onclick="openBatchDeleteModal()">
                    <span class="iconify" data-icon="heroicons:trash" data-width="16"></span>
                    删除节点
                  </button>
                  <button class="btn btn-outline btn-sm w-full justify-start gap-2" onclick="openNeighborQueryModal()">
                    <span class="iconify" data-icon="heroicons:share" data-width="16"></span>
                    邻居节点查询
                  </button>
                  <div class="divider my-2"></div>
                  <div class="text-xs text-base-content/60 mb-3">关系操作</div>
                  <button class="btn btn-outline btn-sm w-full justify-start gap-2" onclick="openAddRelationModal()">
                    <span class="iconify" data-icon="heroicons:link" data-width="16"></span>
                    添加关系
                  </button>
                  <button class="btn btn-outline btn-sm w-full justify-start gap-2" onclick="openDeleteRelationModal()">
                    <span class="iconify" data-icon="heroicons:scissors" data-width="16"></span>
                    删除关系
                  </button>
              </div>
            </div>
          </div>
        </div>
        </div>
        <!-- Left Sidebar Toggle Button -->
        <button id="leftSidebarToggle" class="absolute left-[320px] top-1/2 -translate-y-1/2 z-20 bg-base-200 border border-base-300 rounded-r-lg p-1 hover:bg-base-300 transition-all" onclick="toggleLeftSidebar()" title="收起/展开左侧栏">
          <span class="iconify text-base-content" data-icon="heroicons:chevron-left" data-width="16" id="leftToggleIcon"></span>
        </button>
        <!-- Left Resize Handle -->
        <div id="leftResizeHandle" class="absolute left-[320px] top-0 bottom-0 w-1 cursor-col-resize bg-transparent hover:bg-primary/30 z-10"></div>
        <!-- Main Graph Area -->
        <div class="flex-1 flex flex-col">
          <!-- Graph Statistics Section -->
          <div class="bg-base-100 border-b academic-border"></div>
          <!-- Graph Visualization Area -->
          <div id="graphVisualizationArea" class="flex-1 relative bg-base-100">
            <!-- Graph Canvas -->
            <div id="graphCanvas" class="w-full h-full relative overflow-hidden graphCanvas spark-custom-graphCanvas">
              <!-- Graph visualization will be rendered here -->
              <div class="absolute inset-0 flex items-center justify-center">
                <div class="text-center">
                  <div class="loading loading-spinner loading-lg text-primary mb-4"></div>
                  <p class="text-base-content/70">正在加载知识图谱...</p>
                </div>
              </div>
            </div>
            <!-- Graph Controls Overlay -->
            <div class="absolute top-6 left-6 flex flex-col gap-3">
              <div data-tip="放大" class="tooltip tooltip-right">
                <button id="i3qyic" class="btn btn-circle btn-sm bg-base-100/90 border academic-border hover-lift i3qyic spark-custom-i3qyic" onclick="zoomIn()">
                  <span class="iconify text-base-content" data-icon="heroicons:plus" data-width="16"></span>
                </button>
              </div>
              <div data-tip="缩小" class="tooltip tooltip-right">
                <button class="btn btn-circle btn-sm bg-base-100/90 border academic-border hover-lift" onclick="zoomOut()">
                  <span class="iconify text-base-content" data-icon="heroicons:minus" data-width="16"></span>
                </button>
              </div>
              <div data-tip="重置视图" class="tooltip tooltip-right">
                <button class="btn btn-circle btn-sm bg-base-100/90 border academic-border hover-lift" onclick="resetView()">
                  <span class="iconify text-base-content" data-icon="heroicons:arrow-path" data-width="16"></span>
                </button>
              </div>
            </div>
          </div>
        </div>
        <!-- Right Resize Handle -->
        <div id="rightResizeHandle" class="absolute right-[316px] top-0 bottom-0 w-1 cursor-col-resize bg-transparent hover:bg-primary/30 z-10"></div>
        <!-- Right Sidebar Toggle Button -->
        <button id="rightSidebarToggle" class="absolute right-[300px] top-1/2 -translate-y-1/2 z-20 bg-base-200 border border-base-300 rounded-l-lg p-1 hover:bg-base-300 transition-all" onclick="toggleRightSidebar()" title="收起/展开右侧栏">
          <span class="iconify text-base-content" data-icon="heroicons:chevron-right" data-width="16" id="rightToggleIcon"></span>
        </button>
        <!-- Right Sidebar - Node Details -->
        <div id="rightSidebar" class="bg-base-200 border-l academic-border flex flex-col" style="width: 300px;">
          <div class="sidebar-content">
            <!-- Header -->
            <div class="p-4 border-b academic-border">
              <h3 class="text-sm font-semibold text-base-content flex items-center gap-2">
                <span class="iconify text-primary" data-icon="heroicons:information-circle" data-width="18"></span>
                节点详情
              </h3>
            </div>
            <!-- Node Info Content -->
            <div id="nodeDetailContent" class="p-4 flex-1 overflow-y-auto">
              <div class="text-center text-base-content/50 py-8">
                <span class="iconify mx-auto mb-3" data-icon="heroicons:cursor-arrow-rays" data-width="32"></span>
                <p class="text-sm">点击图谱中的节点</p>
                <p class="text-xs mt-1">查看详细信息</p>
              </div>
            </div>
          </div>
        </div>
        <!-- Right Action Panel -->
        <div class="w-16 bg-base-200 border-l academic-border flex flex-col items-center py-6 gap-4">
          <div data-tip="收藏图谱" class="tooltip tooltip-left">
            <button id="favoriteBtn" class="btn btn-circle btn-sm hover-lift focus-primary" onclick="toggleFavorite()">
              <span class="iconify text-base-content" data-icon="heroicons:heart" data-width="20"></span>
            </button>
          </div>
          <div data-tip="分享图谱" class="tooltip tooltip-left">
            <button class="btn btn-circle btn-sm hover-lift focus-primary" onclick="shareGraph()">
              <span class="iconify text-base-content" data-icon="heroicons:share" data-width="20"></span>
            </button>
          </div>
          <div data-tip="下载图谱" class="tooltip tooltip-left">
            <button class="btn btn-circle btn-sm hover-lift focus-primary" onclick="downloadGraph()">
              <span class="iconify text-base-content" data-icon="heroicons:arrow-down-tray" data-width="20"></span>
            </button>
          </div>
          <div data-tip="全屏显示" class="tooltip tooltip-left">
            <button class="btn btn-circle btn-sm hover-lift focus-primary" onclick="toggleFullscreen()">
              <span class="iconify text-base-content" data-icon="heroicons:arrows-pointing-out" data-width="20"></span>
            </button>
          </div>
        </div>
      </div>
      <!-- Related Graph Recommendations Section -->
      <div id="ijdr1z" class="p-6 ijdr1z spark-custom-ijdr1z">
        <div class="flex items-center justify-between mb-6">
          <h2 class="text-lg font-semibold text-base-content">图谱统计概览</h2>
          <button class="btn btn-ghost btn-sm" onclick="toggleStatistics()">
            <span class="iconify" data-icon="heroicons:chevron-up" data-width="16" id="statsToggleIcon"></span>
          </button>
        </div>
        <div id="statisticsContent" class="space-y-6">
          <!-- Key Metrics -->
          <div class="grid grid-cols-4 gap-4">
            <div class="stat bg-base-200 rounded-lg p-4">
              <div class="stat-title text-xs">节点总数</div>
              <div class="stat-value text-lg text-primary">156</div>
            </div>
            <div class="stat bg-base-200 rounded-lg p-4">
              <div class="stat-title text-xs">关系总数</div>
              <div class="stat-value text-lg text-secondary">284</div>
            </div>
            <div class="stat bg-base-200 rounded-lg p-4">
              <div class="stat-title text-xs">平均连接度</div>
              <div class="stat-value text-lg text-accent">3.6</div>
            </div>
            <div class="stat bg-base-200 rounded-lg p-4">
              <div class="stat-title text-xs">图谱密度</div>
              <div class="stat-value text-lg text-info">0.23</div>
            </div>
          </div>
          <!-- Chart Selection and Display -->
          <div id="i1o35t" class="bg-base-200 rounded-lg p-6 i1o35t spark-custom-i1o35t">
            <div class="flex items-center justify-between mb-4">
              <h3 class="text-sm font-medium">统计图表</h3>
              <div id="iwjh1f" class="dropdown dropdown-end iwjh1f spark-custom-iwjh1f">
                <button tabindex="0" role="button" class="btn btn-outline btn-sm">
                  <span id="selectedChartType">节点类型分布饼状图</span><span class="iconify" data-icon="heroicons:chevron-down" data-width="16"></span>
                </button>
                <ul tabindex="0" class="dropdown-content z-50 menu p-2 shadow bg-base-100 rounded-box w-64 mt-2">
                  <li><a onclick="selectChart(&#39;nodeTypePie&#39;)">节点类型分布饼状图</a></li>
                  <li><a onclick="selectChart(&#39;relationTypePie&#39;)">关系类型分布饼状图</a></li>
                  <li><a onclick="selectChart(&#39;coreNodes&#39;)">核心节点排行榜</a></li>
                  <li><a onclick="selectChart(&#39;stats&#39;)">图谱基础统计</a></li>
                  <li><a onclick="selectChart(&#39;thumbnail&#39;)">图谱缩略图</a></li>
                </ul>
              </div>
            </div>
            <div id="chartContainer" class="h-64 bg-base-100 rounded flex items-center justify-center chartContainer spark-custom-chartContainer">
              <img alt="节点类型分布饼状图" class="rounded" data-src="placehold.co/400x240.png?text=Node+Type+Distribution+Pie+Chart">
            </div>
          </div>
        </div>
      </div>
      <div class="bg-base-200 border-t academic-border">
        <div class="p-6">
          <h2 class="text-lg font-semibold text-base-content mb-6">
            相关图谱推荐
          </h2>
          <div id="recommendationsContainer" class="flex gap-6 overflow-x-auto pb-2">
            <!-- Recommendation cards -->
            <div data-repeatable="true" class="card w-64 bg-base-100 shadow-soft hover-lift shrink-0 cursor-pointer" onclick="navigateTo(&#39;graph_detail_page&#39;)">
              <figure class="h-32">
                <img loading="lazy" decoding="async" fetchpriority="low" src="https://spark-builder.s3.cn-north-1.amazonaws.com.cn/image/2025/10/28/5799cbb3-9457-4add-bf87-22d2520d9900.png" alt="机器学习基础图谱" class="w-full h-full object-cover">
              </figure>
              <div class="card-body p-4">
                <h3 class="card-title text-sm">机器学习基础</h3>
                <p class="text-xs text-base-content/70 line-clamp-2">
                  涵盖监督学习、无监督学习、强化学习等核心算法
                </p>
                <div class="flex gap-1 mt-2">
                  <div class="badge badge-outline badge-xs">算法</div>
                  <div class="badge badge-outline badge-xs">基础</div>
                </div>
              </div>
            </div>
            <div data-repeatable="true" class="card w-64 bg-base-100 shadow-soft hover-lift shrink-0 cursor-pointer" onclick="navigateTo(&#39;graph_detail_page&#39;)">
              <figure class="h-32">
                <img loading="lazy" decoding="async" fetchpriority="low" src="https://spark-builder.s3.cn-north-1.amazonaws.com.cn/image/2025/10/28/2f145208-90a2-40f1-a32d-6cdb765d39a1.png" alt="神经网络架构图谱" class="w-full h-full object-cover">
              </figure>
              <div class="card-body p-4">
                <h3 class="card-title text-sm">神经网络架构</h3>
                <p class="text-xs text-base-content/70 line-clamp-2">
                  从感知机到深度神经网络的演进历程
                </p>
                <div class="flex gap-1 mt-2">
                  <div class="badge badge-outline badge-xs">神经网络</div>
                  <div class="badge badge-outline badge-xs">架构</div>
                </div>
              </div>
            </div>
            <div data-repeatable="true" class="card w-64 bg-base-100 shadow-soft hover-lift shrink-0 cursor-pointer" onclick="navigateTo(&#39;graph_detail_page&#39;)">
              <figure class="h-32">
                <img loading="lazy" decoding="async" fetchpriority="low" src="https://spark-builder.s3.cn-north-1.amazonaws.com.cn/image/2025/10/28/0333837b-d9e1-4e93-9607-4d11e714a5d6.png" alt="计算机视觉图谱" class="w-full h-full object-cover">
              </figure>
              <div class="card-body p-4">
                <h3 class="card-title text-sm">计算机视觉</h3>
                <p class="text-xs text-base-content/70 line-clamp-2">
                  图像处理、目标检测、图像分割等技术体系
                </p>
                <div class="flex gap-1 mt-2">
                  <div class="badge badge-outline badge-xs">视觉</div>
                  <div class="badge badge-outline badge-xs">图像</div>
                </div>
              </div>
            </div>
            <div data-repeatable="true" class="card w-64 bg-base-100 shadow-soft hover-lift shrink-0 cursor-pointer" onclick="navigateTo(&#39;graph_detail_page&#39;)">
              <figure class="h-32">
                <img loading="lazy" decoding="async" fetchpriority="low" src="https://spark-builder.s3.cn-north-1.amazonaws.com.cn/image/2025/10/28/70b0ea03-c4c9-43ca-9435-0f154a156133.png" alt="自然语言处理图谱" class="w-full h-full object-cover">
              </figure>
              <div class="card-body p-4">
                <h3 class="card-title text-sm">自然语言处理</h3>
                <p class="text-xs text-base-content/70 line-clamp-2">
                  文本分析、语言模型、机器翻译等NLP技术
                </p>
                <div class="flex gap-1 mt-2">
                  <div class="badge badge-outline badge-xs">NLP</div>
                  <div class="badge badge-outline badge-xs">语言</div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <!-- Share Modal -->
    <dialog id="shareModal" class="modal">
      <div class="modal-box">
        <form method="dialog">
          <button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">
            ✕
          </button>
        </form>
        <h3 class="font-bold text-lg mb-6">分享图谱</h3>
        <div class="space-y-4">
          <div>
            <label class="label"><span class="label-text">分享链接</span></label>
            <div class="join w-full">
              <input type="text" id="shareLink" readonly="" value="" class="input input-bordered join-item flex-1"><button id="copyShareBtn" class="btn btn-primary join-item" onclick="copyShareLink()">
                <span class="iconify" data-icon="heroicons:clipboard-document" data-width="16"></span>
                复制
              </button>
            </div>
          </div>
          <div class="text-sm text-base-content/70">
            通过此链接，其他用户可以直接访问这个知识图谱
          </div>
        </div>
      </div>
      <form method="dialog" class="modal-backdrop"><button>close</button></form>
    </dialog>
    <!-- Download Modal -->
    <dialog id="downloadModal" class="modal">
      <div class="modal-box">
        <form method="dialog">
          <button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">
            ✕
          </button>
        </form>
        <h3 class="font-bold text-lg mb-6">下载图谱</h3>
        <div class="space-y-4">
          <div>
            <label class="label"><span class="label-text">下载链接</span></label>
            <div class="join w-full">
              <input type="text" id="downloadLink" readonly="" value="" class="input input-bordered join-item flex-1"><button id="copyDownloadBtn" class="btn btn-primary join-item" onclick="copyDownloadLink()">
                <span class="iconify" data-icon="heroicons:clipboard-document" data-width="16"></span>
                复制
              </button>
            </div>
          </div>
          <div class="space-y-2">
            <div class="text-sm font-medium text-base-content">可用格式：</div>
            <div class="flex gap-2">
              <button class="btn btn-outline btn-sm" onclick="downloadFormat(&#39;json&#39;)">
                <span class="iconify" data-icon="heroicons:document-text" data-width="16"></span>
                JSON</button><button class="btn btn-outline btn-sm" onclick="downloadFormat(&#39;csv&#39;)">
                <span class="iconify" data-icon="heroicons:table-cells" data-width="16"></span>
                CSV</button><button class="btn btn-outline btn-sm" onclick="downloadFormat(&#39;png&#39;)">
                <span class="iconify" data-icon="heroicons:photo" data-width="16"></span>
                PNG
              </button>
            </div>
          </div>
          <div class="text-sm text-base-content/70">
            选择格式后将生成对应的下载链接
          </div>
        </div>
      </div>
      <form method="dialog" class="modal-backdrop"><button>close</button></form>
    </dialog>
    
    <!-- Import Node Modal -->
    <dialog id="batchImportModal" class="modal">
      <div class="modal-box max-w-2xl">
        <form method="dialog">
          <button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button>
        </form>
        <h3 class="font-bold text-lg mb-4">
          <span class="iconify inline-block mr-2" data-icon="heroicons:arrow-up-tray" data-width="20"></span>
          导入节点
        </h3>
        <div class="space-y-4">
          <!-- Tab Selection -->
          <div class="tabs tabs-boxed">
            <a class="tab tab-active" id="singleImportTab" onclick="switchImportTab(&#39;single&#39;)">单个添加</a>
            <a class="tab" id="batchImportTab" onclick="switchImportTab(&#39;batch&#39;)">批量导入</a>
          </div>
          
          <!-- Single Import Form -->
          <div id="singleImportForm" class="space-y-3">
            <div class="form-control">
              <label class="label"><span class="label-text">节点名称 *</span></label>
              <input type="text" id="singleNodeName" class="input input-bordered" placeholder="输入节点名称">
            </div>
            <div class="form-control">
              <label class="label"><span class="label-text">节点类型</span></label>
              <input type="text" id="singleNodeType" class="input input-bordered" placeholder="输入节点类型（如：概念、算法等）">
            </div>
            <div class="form-control">
              <label class="label"><span class="label-text">节点简介（可选）</span></label>
              <textarea id="singleNodeDescription" class="textarea textarea-bordered h-20" placeholder="输入节点的简介描述..."></textarea>
            </div>
            <div class="form-control">
              <label class="label"><span class="label-text">重要性（1-10）</span></label>
              <input type="number" id="singleNodeImportance" class="input input-bordered" min="1" max="10" value="5">
            </div>
          </div>
          
          <!-- Batch Import Form -->
          <div id="batchImportForm" class="space-y-3 hidden">
            <div class="alert alert-info">
              <span class="iconify" data-icon="heroicons:information-circle" data-width="20"></span>
              <span>每行一个节点，格式: 节点名称,类型,简介,重要性(可选)</span>
            </div>
            <textarea id="batchImportInput" class="textarea textarea-bordered w-full h-40" placeholder="节点1,概念,这是节点1的简介,5
节点2,算法,这是节点2的简介,3
节点3,工具,这是节点3的简介"></textarea>
          </div>
          
          <div class="flex justify-end gap-2">
            <button class="btn btn-ghost" onclick="document.getElementById(&#39;batchImportModal&#39;).close()">取消</button>
            <button class="btn btn-primary" onclick="executeImportNodes()">
              <span class="iconify" data-icon="heroicons:plus" data-width="16"></span>
              添加
            </button>
          </div>
        </div>
      </div>
      <form method="dialog" class="modal-backdrop"><button>close</button></form>
    </dialog>
    
    <!-- Delete Node Modal -->
    <dialog id="batchDeleteModal" class="modal">
      <div class="modal-box max-w-2xl">
        <form method="dialog">
          <button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button>
        </form>
        <h3 class="font-bold text-lg mb-4">
          <span class="iconify inline-block mr-2" data-icon="heroicons:trash" data-width="20"></span>
          删除节点
        </h3>
        <div class="space-y-4">
          <div class="form-control">
            <label class="label"><span class="label-text">按类型筛选</span></label>
            <select id="deleteTypeFilter" class="select select-bordered" onchange="filterDeleteNodes()">
              <option value="">全部类型</option>
            </select>
          </div>
          <div class="form-control">
            <label class="label"><span class="label-text">搜索节点</span></label>
            <input type="text" id="deleteSearchInput" class="input input-bordered" placeholder="输入关键词筛选..." oninput="filterDeleteNodes()">
          </div>
          <div class="border rounded-lg p-3 max-h-60 overflow-y-auto">
            <div id="deleteNodeList" class="space-y-2">
              <div class="text-sm text-base-content/50 text-center">加载节点列表...</div>
            </div>
          </div>
          <div class="flex justify-between items-center">
            <div class="flex gap-2">
              <button class="btn btn-ghost btn-sm" onclick="selectAllDeleteNodes()">全选</button>
              <button class="btn btn-ghost btn-sm" onclick="deselectAllDeleteNodes()">取消全选</button>
            </div>
            <span id="selectedDeleteCount" class="text-sm text-base-content/70">已选择 0 个节点</span>
          </div>
          <div class="flex justify-end gap-2">
            <button class="btn btn-ghost" onclick="document.getElementById(&#39;batchDeleteModal&#39;).close()">取消</button>
            <button class="btn btn-error" onclick="executeBatchDelete()">
              <span class="iconify" data-icon="heroicons:trash" data-width="16"></span>
              删除选中
            </button>
          </div>
        </div>
      </div>
      <form method="dialog" class="modal-backdrop"><button>close</button></form>
    </dialog>
    
    
    <!-- Neighbor Query Modal -->
    <dialog id="neighborQueryModal" class="modal">
      <div class="modal-box max-w-2xl">
        <form method="dialog">
          <button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button>
        </form>
        <h3 class="font-bold text-lg mb-4">
          <span class="iconify inline-block mr-2" data-icon="heroicons:share" data-width="20"></span>
          邻居节点查询
        </h3>
        <div class="space-y-4">
          <div class="form-control">
            <label class="label"><span class="label-text">选择目标节点</span></label>
            <input type="text" id="neighborTargetNodeInput" list="neighborTargetNodeList" class="input input-bordered w-full" placeholder="输入或选择节点...">
            <datalist id="neighborTargetNodeList"></datalist>
          </div>
          <div class="form-control">
            <label class="label"><span class="label-text">查询方向</span></label>
            <select id="neighborDirection" class="select select-bordered">
              <option value="all">所有邻居</option>
              <option value="out">出边邻居（该节点指向的）</option>
              <option value="in">入边邻居（指向该节点的）</option>
            </select>
          </div>
          <div class="flex justify-end gap-2">
            <button class="btn btn-ghost" onclick="document.getElementById(&#39;neighborQueryModal&#39;).close()">取消</button>
            <button class="btn btn-primary" onclick="executeNeighborQuery()">
              <span class="iconify" data-icon="heroicons:magnifying-glass" data-width="16"></span>
              查询
            </button>
          </div>
          <div id="neighborResults" class="border rounded-lg p-3 max-h-60 overflow-y-auto hidden">
            <div class="text-sm font-medium mb-2">邻居节点列表</div>
            <div id="neighborResultList" class="space-y-2"></div>
          </div>
        </div>
      </div>
      <form method="dialog" class="modal-backdrop"><button>close</button></form>
    </dialog>
    
    
    <!-- Add Relation Modal -->
    <dialog id="addRelationModal" class="modal">
      <div class="modal-box max-w-2xl">
        <form method="dialog">
          <button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button>
        </form>
        <h3 class="font-bold text-lg mb-4">
          <span class="iconify inline-block mr-2" data-icon="heroicons:link" data-width="20"></span>
          添加关系
        </h3>
        <!-- Tab切换 -->
        <div class="tabs tabs-boxed mb-4">
          <a id="singleRelationTab" class="tab tab-active" onclick="switchRelationTab(&#39;single&#39;)">单条添加</a>
          <a id="batchRelationTab" class="tab" onclick="switchRelationTab(&#39;batch&#39;)">批量添加</a>
        </div>
        <!-- 单条添加表单 -->
        <div id="singleRelationForm" class="space-y-4">
          <div class="form-control">
            <label class="label"><span class="label-text">源节点 *</span></label>
            <input type="text" id="newRelationSourceInput" list="newRelationSourceList" class="input input-bordered w-full" placeholder="输入或选择源节点..." required>
            <datalist id="newRelationSourceList"></datalist>
          </div>
          <div class="form-control">
            <label class="label"><span class="label-text">目标节点 *</span></label>
            <input type="text" id="newRelationTargetInput" list="newRelationTargetList" class="input input-bordered w-full" placeholder="输入或选择目标节点..." required>
            <datalist id="newRelationTargetList"></datalist>
          </div>
          <div class="form-control">
            <label class="label"><span class="label-text">关系类型</span></label>
            <input type="text" id="newRelationType" class="input input-bordered" placeholder="输入关系类型（如：包含、依赖等）" value="关联">
          </div>
          <div class="flex justify-end gap-2">
            <button class="btn btn-ghost" onclick="document.getElementById(&#39;addRelationModal&#39;).close()">取消</button>
            <button class="btn btn-primary" onclick="executeAddRelation()">
              <span class="iconify" data-icon="heroicons:link" data-width="16"></span>
              添加
            </button>
          </div>
        </div>
        <!-- 批量添加表单 -->
        <div id="batchRelationForm" class="space-y-4 hidden">
          <div class="alert alert-info text-sm">
            <span class="iconify" data-icon="heroicons:information-circle" data-width="16"></span>
            <span>每行一条关系，格式：源节点名称,目标节点名称,关系类型</span>
          </div>
          <div class="form-control">
            <label class="label"><span class="label-text">批量关系数据</span></label>
            <textarea id="batchRelationInput" class="textarea textarea-bordered h-40 font-mono text-sm" placeholder="示例：
张三,李四,朋友
北京,中国,属于
人工智能,机器学习,包含"></textarea>
          </div>
          <div id="batchRelationPreview" class="border rounded-lg p-3 max-h-40 overflow-y-auto hidden">
            <div class="text-xs text-base-content/60 mb-2">预览（将添加以下关系）：</div>
            <div id="batchRelationPreviewList" class="space-y-1"></div>
          </div>
          <div class="flex justify-between items-center">
            <button class="btn btn-ghost btn-sm" onclick="previewBatchRelations()">
              <span class="iconify" data-icon="heroicons:eye" data-width="16"></span>
              预览
            </button>
            <div class="flex gap-2">
              <button class="btn btn-ghost" onclick="document.getElementById(&#39;addRelationModal&#39;).close()">取消</button>
              <button class="btn btn-primary" onclick="executeBatchAddRelations()">
                <span class="iconify" data-icon="heroicons:plus-circle" data-width="16"></span>
                批量添加
              </button>
            </div>
          </div>
        </div>
      </div>
      <form method="dialog" class="modal-backdrop"><button>close</button></form>
    </dialog>
    
    <!-- Delete Relation Modal -->
    <dialog id="deleteRelationModal" class="modal">
      <div class="modal-box max-w-2xl">
        <form method="dialog">
          <button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button>
        </form>
        <h3 class="font-bold text-lg mb-4">
          <span class="iconify inline-block mr-2" data-icon="heroicons:scissors" data-width="20"></span>
          删除关系
        </h3>
        <div class="space-y-4">
          <div class="form-control">
            <label class="label"><span class="label-text">按关系类型筛选</span></label>
            <select id="deleteRelationTypeFilter" class="select select-bordered" onchange="filterDeleteRelations()">
              <option value="">全部类型</option>
            </select>
          </div>
          <div class="form-control">
            <label class="label"><span class="label-text">搜索关系</span></label>
            <input type="text" id="deleteRelationSearchInput" class="input input-bordered" placeholder="输入节点名称筛选..." oninput="filterDeleteRelations()">
          </div>
          <div class="border rounded-lg p-3 max-h-60 overflow-y-auto">
            <div id="deleteRelationList" class="space-y-2">
              <div class="text-sm text-base-content/50 text-center">加载关系列表...</div>
            </div>
          </div>
          <div class="flex justify-between items-center">
            <div class="flex gap-2">
              <button class="btn btn-ghost btn-sm" onclick="selectAllDeleteRelations()">全选</button>
              <button class="btn btn-ghost btn-sm" onclick="deselectAllDeleteRelations()">取消全选</button>
            </div>
            <span id="selectedDeleteRelationCount" class="text-sm text-base-content/70">已选择 0 个关系</span>
          </div>
          <div class="flex justify-end gap-2">
            <button class="btn btn-ghost" onclick="document.getElementById(&#39;deleteRelationModal&#39;).close()">取消</button>
            <button class="btn btn-error" onclick="executeBatchDeleteRelations()">
              <span class="iconify" data-icon="heroicons:trash" data-width="16"></span>
              删除选中
            </button>
          </div>
        </div>
      </div>
      <form method="dialog" class="modal-backdrop"><button>close</button></form>
    </dialog>
    
    <!-- Edit Node Modal -->
    <dialog id="editNodeModal" class="modal">
      <div class="modal-box">
        <form method="dialog">
          <button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button>
        </form>
        <h3 class="font-bold text-lg mb-4">
          <span class="iconify inline-block mr-2" data-icon="heroicons:pencil-square" data-width="20"></span>
          编辑节点
        </h3>
        <div class="space-y-4">
          <input type="hidden" id="editNodeId">
          <div class="form-control">
            <label class="label"><span class="label-text">节点名称 *</span></label>
            <input type="text" id="editNodeName" class="input input-bordered" placeholder="输入节点名称">
          </div>
          <div class="form-control">
            <label class="label"><span class="label-text">节点类型</span></label>
            <input type="text" id="editNodeType" class="input input-bordered" placeholder="输入节点类型">
          </div>
          <div class="form-control">
            <label class="label"><span class="label-text">节点简介</span></label>
            <textarea id="editNodeDescription" class="textarea textarea-bordered h-24" placeholder="输入节点的简介描述..."></textarea>
          </div>
          <div class="form-control">
            <label class="label"><span class="label-text">重要性（1-10）</span></label>
            <input type="number" id="editNodeImportance" class="input input-bordered" min="1" max="10" value="5">
          </div>
          <div class="flex justify-end gap-2">
            <button class="btn btn-ghost" onclick="document.getElementById(&#39;editNodeModal&#39;).close()">取消</button>
            <button class="btn btn-primary" onclick="executeEditNode()">
              <span class="iconify" data-icon="heroicons:check" data-width="16"></span>
              保存
            </button>
          </div>
        </div>
      </div>
      <form method="dialog" class="modal-backdrop"><button>close</button></form>
    </dialog>
    
    <!-- Footer -->
    <div class="footer-wrapper"><div data-section-id="common_footer" data-section-type="common_footer">
<footer class="footer footer-center p-6 bg-base-200 text-base-content border-t academic-border">
<div class="grid grid-flow-col gap-4">
<a onclick="navigateTo(&#39;about_page&#39;)" class="link link-hover focus-primary">关于我们</a>
<a onclick="navigateTo(&#39;documentation_page&#39;)" class="link link-hover focus-primary">帮助中心</a>
<a onclick="navigateTo(&#39;feedback_page&#39;)" class="link link-hover focus-primary">用户反馈</a>
<a class="link link-hover focus-primary">隐私政策</a>
<a class="link link-hover focus-primary">服务条款</a>
</div>
<div class="grid grid-flow-col gap-4">
<a class="link link-hover focus-primary" aria-label="官方微信">
<span class="iconify" data-icon="simple-icons:wechat" data-width="20" style="color: var(--color-success);"></span>
</a>
<a class="link link-hover focus-primary" aria-label="企业QQ">
<span class="iconify" data-icon="simple-icons:tencentqq" data-width="20" style="color: var(--color-primary);"></span>
</a>
<a onclick="navigateTo(&#39;feedback_page&#39;)" class="link link-hover focus-primary" aria-label="意见反馈">
<span class="iconify" data-icon="heroicons:chat-bubble-left-right" data-width="20"></span>
</a>
</div>
<div class="text-center">
<p>© 2025 Graph+知识图谱平台. 版权所有 | <span class="text-primary font-medium">智慧知识发现与探索</span></p>
<p class="text-xs opacity-70 mt-1">反馈邮箱: feedback@knowledgegraph.com</p>
</div>
</footer>
</div></div>
    <script>
(function() {
&#39;use strict&#39;;

// Initialize global namespace
window.APP_GLOBALS = window.APP_GLOBALS || {};

// Global navigation utility
window.navigateTo = function(targetPageId) {
const isInIframe = window.self !== window.top;
const targetFileName = `${targetPageId}.html`;

if (isInIframe) {
window.parent.postMessage({
type: &#39;iframeNavigation&#39;,
targetPageId: targetPageId
}, &#39;*&#39;);
} else {
window.location.href = targetFileName;
}
};

// User authentication state management
window.APP_GLOBALS.user = {
isLoggedIn: false,
userInfo: null,

login: function(userInfo) {
this.isLoggedIn = true;
this.userInfo = userInfo;
localStorage.setItem(&#39;userState&#39;, JSON.stringify({
isLoggedIn: true,
userInfo: userInfo
}));
this.updateUserInterface();
},

logout: function() {
this.isLoggedIn = false;
this.userInfo = null;
localStorage.removeItem(&#39;userState&#39;);
fetch(&#39;/api/auth/logout&#39;, { method: &#39;POST&#39;, credentials: &#39;include&#39; })
.finally(() =&gt; {
this.updateUserInterface();
window.top.location.href = &#39;/graph/home.html&#39;;
});
},

updateUserInterface: function() {
const userControls = document.querySelectorAll(&#39;[data-user-control]&#39;);
userControls.forEach(control => {
const controlType = control.getAttribute(&#39;data-user-control&#39;);
if (controlType === &#39;logged-out&#39; &amp;&amp; this.isLoggedIn) {
control.style.display = &#39;none&#39;;
} else if (controlType === &#39;logged-in&#39; &amp;&amp; !this.isLoggedIn) {
control.style.display = &#39;none&#39;;
} else {
control.style.display = &#39;&#39;;
}
});
},

init: function() {
const savedState = localStorage.getItem(&#39;userState&#39;);
if (savedState) {
const state = JSON.parse(savedState);
this.isLoggedIn = state.isLoggedIn;
this.userInfo = state.userInfo;
}
this.updateUserInterface();
}
};

// Search functionality
window.APP_GLOBALS.search = {
history: JSON.parse(localStorage.getItem(&#39;searchHistory&#39;) || &#39;[]&#39;),
recommendations: [&#39;人工智能&#39;, &#39;机器学习&#39;, &#39;自然语言处理&#39;, &#39;计算机视觉&#39;, &#39;深度学习&#39;],

addToHistory: function(query) {
if (query &amp;&amp; !this.history.includes(query)) {
this.history.unshift(query);
this.history = this.history.slice(0, 10); // Keep only last 10 searches
localStorage.setItem(&#39;searchHistory&#39;, JSON.stringify(this.history));
}
},

getSearchSuggestions: function() {
return this.history.length > 0 ? this.history : this.recommendations;
},

performSearch: function(query, targetPage = &#39;graph_list_page&#39;) {
this.addToHistory(query);
// Navigate to search results or graph detail based on context
navigateTo(targetPage);
}
};

// Notification utilities
window.showNotification = function(message, type = &#39;info&#39;) {
const notification = document.createElement(&#39;div&#39;);
notification.className = `alert alert-${type} fixed top-4 right-4 w-96 z-50 shadow-lg`;
notification.innerHTML = `
<div class="flex items-center gap-2">
<span class="iconify" data-icon="heroicons:information-circle-solid" data-width="20"></span>
<span>${message}</span>
</div>
`;
document.body.appendChild(notification);

setTimeout(() => {
notification.remove();
}, 5000);
};

// Favorites management
window.APP_GLOBALS.favorites = {
items: JSON.parse(localStorage.getItem(&#39;favorites&#39;) || &#39;[]&#39;),

add: function(graphId, graphData) {
if (!this.items.find(item => item.id === graphId)) {
this.items.push({
id: graphId,
data: graphData,
addedAt: new Date().toISOString()
});
localStorage.setItem(&#39;favorites&#39;, JSON.stringify(this.items));
showNotification(&#39;已添加到收藏&#39;, &#39;success&#39;);
}
},

remove: function(graphId) {
this.items = this.items.filter(item => item.id !== graphId);
localStorage.setItem(&#39;favorites&#39;, JSON.stringify(this.items));
showNotification(&#39;已从收藏中移除&#39;, &#39;info&#39;);
},

isFavorited: function(graphId) {
return this.items.some(item => item.id === graphId);
},

toggle: function(graphId, graphData) {
if (this.isFavorited(graphId)) {
this.remove(graphId);
} else {
this.add(graphId, graphData);
}
}
};

// Initialize components when DOM is loaded
document.addEventListener(&#39;DOMContentLoaded&#39;, function() {
window.APP_GLOBALS.user.init();
});

})();
</script><script>
(function() {
    &#39;use strict&#39;;

    // Graph state management
    let currentGraphData = {
        id: null,
        name: &#39;&#39;,
        description: &#39;&#39;,
        nodes: [],
        edges: [],
        selectedNode: null,
        nodeCount: 0,
        relationCount: 0
    };

    let graphZoom = 1;
    let graphPan = { x: 0, y: 0 };
    let isFullscreen = false;
    let statisticsCollapsed = false;
    let currentChartType = &#39;pie&#39;;

    // Chart type mapping
    const chartTypes = {
        &#39;nodeTypePie&#39;: { name: &#39;节点类型分布饼状图&#39; },
        &#39;relationTypePie&#39;: { name: &#39;关系类型分布饼状图&#39; },
        &#39;coreNodes&#39;: { name: &#39;核心节点排行榜&#39; },
        &#39;stats&#39;: { name: &#39;图谱基础统计&#39; },
        &#39;thumbnail&#39;: { name: &#39;图谱缩略图&#39; }
    };

    // Get graph ID from URL
    function getGraphIdFromUrl() {
        // Check parent window URL first (iframe case)
        let url = window.location.href;
        try {
            if (window.parent &amp;&amp; window.parent.location) {
                url = window.parent.location.href;
            }
        } catch(e) { /* cross-origin, use current */ }
        
        const urlParams = new URLSearchParams(url.split(&#39;?&#39;)[1] || &#39;&#39;);
        return urlParams.get(&#39;id&#39;);
    }

    // Load graph data from API
    async function loadGraphData(graphId) {
        if (!graphId) {
            console.log(&#39;No graph ID provided&#39;);
            return null;
        }
        
        try {
            // Load graph metadata
            const graphResponse = await fetch(`/api/graph/${graphId}?incrementView=true`);
            if (!graphResponse.ok) {
                throw new Error(&#39;Failed to load graph&#39;);
            }
            const graphInfo = await graphResponse.json();
            
            // Load nodes
            const nodesResponse = await fetch(`/api/graph/${graphId}/nodes`);
            const nodesData = nodesResponse.ok ? await nodesResponse.json() : { nodes: [] };
            console.log(&#39;Nodes API response:&#39;, nodesData);
            
            // Load relations
            const relationsResponse = await fetch(`/api/graph/${graphId}/relations`);
            console.log(&#39;Relations API status:&#39;, relationsResponse.status, relationsResponse.ok);
            const relationsData = relationsResponse.ok ? await relationsResponse.json() : { relations: [] };
            console.log(&#39;Relations API response:&#39;, relationsData);
            
            // Check edit permission
            let canEdit = false;
            try {
                const permResponse = await fetch(`/api/graph/${graphId}/can-edit`, { credentials: &#39;include&#39; });
                if (permResponse.ok) {
                    const permData = await permResponse.json();
                    canEdit = permData.canEdit === true;
                }
            } catch (e) {
                console.log(&#39;Permission check failed, defaulting to no edit&#39;);
            }
            
            return {
                id: graphId,
                name: graphInfo.name || &#39;未命名图谱&#39;,
                description: graphInfo.description || &#39;&#39;,
                nodes: nodesData.nodes || [],
                edges: relationsData.relations || [],
                nodeCount: graphInfo.nodeCount || 0,
                relationCount: graphInfo.relationCount || 0,
                viewCount: graphInfo.viewCount || 0,
                collectCount: graphInfo.collectCount || 0,
                shareLink: graphInfo.shareLink || &#39;&#39;,
                canEdit: canEdit
            };
        } catch (error) {
            console.error(&#39;Error loading graph data:&#39;, error);
            window.showNotification(&#39;加载图谱数据失败&#39;, &#39;error&#39;);
            return null;
        }
    }

    // Update page UI with graph data
    function updatePageWithGraphData(data) {
        if (!data) return;
        
        currentGraphData = { ...currentGraphData, ...data };
        
        // Update title
        const titleEl = document.getElementById(&#39;graphTitle&#39;);
        if (titleEl) titleEl.textContent = data.name || &#39;未命名图谱&#39;;
        
        // Update description
        const descEl = document.getElementById(&#39;graphDescription&#39;);
        if (descEl) descEl.textContent = data.description || &#39;暂无描述&#39;;
        
        // Update tags container
        updateGraphTags(data);
        
        // Update entity type filters from actual data
        updateEntityTypeFiltersFromData(data.nodes || []);
        
        // Update relationship type filters from actual data
        updateRelationshipTypeFiltersFromData(data.edges || []);
        
        // Update search type filter options
        updateSearchTypeFilter(data.nodes || []);
        
        // Update statistics
        updateStatistics(data);
        
        // Show/hide node management section based on edit permission
        const nodeManagementSection = document.getElementById(&#39;nodeManagementSection&#39;);
        if (nodeManagementSection) {
            nodeManagementSection.style.display = data.canEdit ? &#39;block&#39; : &#39;none&#39;;
        }
    }
    
    // Update search type filter options
    function updateSearchTypeFilter(nodes) {
        const typeSelect = document.getElementById(&#39;searchTypeFilter&#39;);
        if (!typeSelect) return;
        
        const types = [...new Set(nodes.map(n =&gt; n.type || &#39;未分类&#39;))];
        typeSelect.innerHTML = &#39;<option value="">全部类型</option>&#39; + 
            types.map(t =&gt; `<option value="${t}">${t}</option>`).join(&#39;&#39;);
    }
    
    // Update graph tags dynamically
    function updateGraphTags(data) {
        const tagsContainer = document.getElementById(&#39;graphTags&#39;);
        if (!tagsContainer) return;
        
        // 从节点类型中提取标签
        const nodeTypes = new Set();
        (data.nodes || []).forEach(node => {
            if (node.type) nodeTypes.add(node.type);
        });
        
        if (nodeTypes.size === 0) {
            tagsContainer.innerHTML = &#39;<div class="badge badge-ghost badge-sm">暂无标签</div>&#39;;
            return;
        }
        
        const colors = [&#39;primary&#39;, &#39;secondary&#39;, &#39;accent&#39;, &#39;info&#39;];
        let html = &#39;&#39;;
        let colorIndex = 0;
        nodeTypes.forEach(type => {
            html += `<div class="badge badge-${colors[colorIndex % colors.length]} badge-sm">${type}</div>`;
            colorIndex++;
        });
        tagsContainer.innerHTML = html;
    }
    
    // Update entity type filters from actual node data
    function updateEntityTypeFiltersFromData(nodes) {
        const container = document.getElementById(&#39;entityTypeFilters&#39;);
        if (!container) return;
        
        // 统计每种类型的节点数量
        const typeCounts = {};
        nodes.forEach(node => {
            const type = node.type || &#39;未分类&#39;;
            typeCounts[type] = (typeCounts[type] || 0) + 1;
        });
        
        if (Object.keys(typeCounts).length === 0) {
            container.innerHTML = &#39;<div class="text-sm text-base-content/50">暂无节点类型数据</div>&#39;;
            return;
        }
        
        let html = &#39;&#39;;
        Object.entries(typeCounts).forEach(([type, count]) => {
            html += `<label class="label cursor-pointer justify-start gap-3 py-1">
                <input type="checkbox" checked data-entity-type="${type}" class="checkbox checkbox-primary checkbox-sm entity-type-checkbox">
                <span class="label-text text-sm">${type} (${count})</span>
            </label>`;
        });
        container.innerHTML = html;
        
        // 重新绑定事件
        container.querySelectorAll(&#39;.entity-type-checkbox&#39;).forEach(cb => {
            cb.addEventListener(&#39;change&#39;, updateNodeVisibilityByType);
        });
    }
    
    // Update relationship type filters from actual edge data
    function updateRelationshipTypeFiltersFromData(edges) {
        const container = document.getElementById(&#39;relationTypeFilters&#39;);
        if (!container) return;
        
        // 统计每种关系类型的数量
        const typeCounts = {};
        edges.forEach(edge => {
            const type = edge.type || &#39;关联&#39;;
            typeCounts[type] = (typeCounts[type] || 0) + 1;
        });
        
        if (Object.keys(typeCounts).length === 0) {
            container.innerHTML = &#39;<div class="text-sm text-base-content/50">暂无关系类型数据</div>&#39;;
            return;
        }
        
        let html = &#39;&#39;;
        Object.entries(typeCounts).forEach(([type, count]) => {
            html += `<label class="label cursor-pointer justify-start gap-3 py-1">
                <input type="checkbox" checked data-relation-type="${type}" class="checkbox checkbox-secondary checkbox-sm relation-type-checkbox">
                <span class="label-text text-sm">${type} (${count})</span>
            </label>`;
        });
        container.innerHTML = html;
        
        // 重新绑定事件
        container.querySelectorAll(&#39;.relation-type-checkbox&#39;).forEach(cb => {
            cb.addEventListener(&#39;change&#39;, updateEdgeVisibilityByType);
        });
    }
    
    // Update node visibility based on type filters
    function updateNodeVisibilityByType() {
        const checkedTypes = [];
        document.querySelectorAll(&#39;.entity-type-checkbox:checked&#39;).forEach(cb => {
            checkedTypes.push(cb.getAttribute(&#39;data-entity-type&#39;));
        });
        
        document.querySelectorAll(&#39;.graph-node&#39;).forEach(node => {
            const nodeType = node.getAttribute(&#39;data-node-type&#39;) || &#39;未分类&#39;;
            node.style.opacity = checkedTypes.includes(nodeType) ? &#39;1&#39; : &#39;0.2&#39;;
        });
    }
    
    // Update edge visibility based on type filters
    function updateEdgeVisibilityByType() {
        const checkedTypes = [];
        document.querySelectorAll(&#39;.relation-type-checkbox:checked&#39;).forEach(cb =&gt; {
            checkedTypes.push(cb.getAttribute(&#39;data-relation-type&#39;));
        });
        
        // 收集选中关系类型两端的节点ID
        const highlightedNodeIds = new Set();
        
        document.querySelectorAll(&#39;.graph-edge&#39;).forEach(edge =&gt; {
            const edgeType = edge.getAttribute(&#39;data-edge-type&#39;) || &#39;关联&#39;;
            const isVisible = checkedTypes.includes(edgeType);
            edge.style.opacity = isVisible ? &#39;0.7&#39; : &#39;0.1&#39;;
            
            // 如果边可见，记录两端节点
            if (isVisible) {
                const sourceId = edge.getAttribute(&#39;data-edge-source&#39;);
                const targetId = edge.getAttribute(&#39;data-edge-target&#39;);
                if (sourceId) highlightedNodeIds.add(sourceId);
                if (targetId) highlightedNodeIds.add(targetId);
            }
        });
        
        // 更新边标签透明度
        document.querySelectorAll(&#39;.edge-label&#39;).forEach(label =&gt; {
            const sourceId = label.getAttribute(&#39;data-label-source&#39;);
            const targetId = label.getAttribute(&#39;data-label-target&#39;);
            const edge = document.querySelector(`[data-edge-source="${sourceId}"][data-edge-target="${targetId}"]`);
            if (edge) {
                const edgeType = edge.getAttribute(&#39;data-edge-type&#39;) || &#39;关联&#39;;
                label.style.opacity = checkedTypes.includes(edgeType) ? &#39;1&#39; : &#39;0.1&#39;;
            }
        });
        
        // 高亮关系两端的节点
        document.querySelectorAll(&#39;.graph-node&#39;).forEach(node =&gt; {
            const nodeId = node.getAttribute(&#39;data-node-id&#39;);
            node.style.opacity = highlightedNodeIds.has(nodeId) ? &#39;1&#39; : &#39;0.2&#39;;
        });
        
        // 更新节点标签透明度
        document.querySelectorAll(&#39;[data-label-for]&#39;).forEach(label =&gt; {
            const nodeId = label.getAttribute(&#39;data-label-for&#39;);
            label.style.opacity = highlightedNodeIds.has(nodeId) ? &#39;1&#39; : &#39;0.2&#39;;
        });
    }

    // Update statistics display
    function updateStatistics(data) {
        const stats = document.querySelectorAll(&#39;.stat .stat-value&#39;);
        if (stats.length >= 4) {
            stats[0].textContent = data.nodeCount || 0;
            stats[1].textContent = data.relationCount || 0;
            // Calculate average degree
            const avgDegree = data.nodeCount > 0 ? ((data.relationCount * 2) / data.nodeCount).toFixed(1) : &#39;0&#39;;
            stats[2].textContent = avgDegree;
            // Calculate density
            const maxEdges = data.nodeCount * (data.nodeCount - 1) / 2;
            const density = maxEdges > 0 ? (data.relationCount / maxEdges).toFixed(2) : &#39;0&#39;;
            stats[3].textContent = density;
        }
    }

    // Initialize page
    document.addEventListener(&#39;DOMContentLoaded&#39;, async function() {
        const graphId = getGraphIdFromUrl();
        
        if (graphId) {
            const data = await loadGraphData(graphId);
            if (data) {
                updatePageWithGraphData(data);
            }
        }
        
        initializeGraph();
        updateFavoriteButton();
        setupSearchFunctionality();
        setupViewControls();
        setupEntityTypeFilters();
        setupRelationshipFilters();
        initializeChart();
        checkAndShowEditSection();
        updateSearchTypeFilter();
    });

// Chart selection function
    window.selectChart = function(chartType) {
        currentChartType = chartType;
        const chart = chartTypes[chartType];
        if (!chart) return;
        
        document.getElementById(&#39;selectedChartType&#39;).textContent = chart.name;
        renderChart(chartType);
        document.activeElement.blur();
    };

    // Render chart based on type
    function renderChart(chartType) {
        const container = document.getElementById(&#39;chartContainer&#39;);
        const nodes = currentGraphData.nodes || [];
        const edges = currentGraphData.edges || [];
        
        switch(chartType) {
            case &#39;nodeTypePie&#39;:
                renderNodeTypePie(container, nodes);
                break;
            case &#39;relationTypePie&#39;:
                renderRelationTypePie(container, edges);
                break;
            case &#39;coreNodes&#39;:
                renderCoreNodes(container, nodes);
                break;
            case &#39;stats&#39;:
                renderStats(container, nodes, edges);
                break;
            case &#39;thumbnail&#39;:
                renderThumbnail(container);
                break;
            default:
                container.innerHTML = &#39;&lt;div class="text-center text-base-content/50"&gt;未知图表类型&lt;/div&gt;&#39;;
        }
    }

    // 1. 节点类型分布饼状图
    function renderNodeTypePie(container, nodes) {
        const typeCount = {};
        nodes.forEach(function(n) {
            const type = n.type || &#39;默认&#39;;
            typeCount[type] = (typeCount[type] || 0) + 1;
        });
        
        const data = Object.entries(typeCount).map(function(entry) {
            return { name: entry[0], value: entry[1], color: getNodeColor(entry[0]) };
        });
        
        if (data.length === 0) {
            container.innerHTML = &#39;&lt;div class="flex items-center justify-center h-full text-base-content/50"&gt;暂无节点数据&lt;/div&gt;&#39;;
            return;
        }
        
        let html = &#39;&lt;div class="flex items-center justify-center h-full gap-6 p-4"&gt;&#39;;
        html += &#39;&lt;div class="flex flex-col gap-2"&gt;&#39;;
        const total = nodes.length;
        data.forEach(function(item) {
            const percent = ((item.value / total) * 100).toFixed(1);
            html += &#39;&lt;div class="flex items-center gap-2 text-sm"&gt;&#39;;
            html += &#39;&lt;div class="w-3 h-3 rounded-full" style="background-color: &#39; + item.color + &#39;;"&gt;&lt;/div&gt;&#39;;
            html += &#39;&lt;span&gt;&#39; + item.name + &#39;&lt;/span&gt;&#39;;
            html += &#39;&lt;span class="text-base-content/50"&gt;&#39; + item.value + &#39; (&#39; + percent + &#39;%)&lt;/span&gt;&#39;;
            html += &#39;&lt;/div&gt;&#39;;
        });
        html += &#39;&lt;/div&gt;&#39;;
        html += &#39;&lt;div class="relative w-32 h-32"&gt;&#39;;
        html += renderPieSVG(data, total);
        html += &#39;&lt;/div&gt;&#39;;
        html += &#39;&lt;/div&gt;&#39;;
        container.innerHTML = html;
    }
    
    // SVG饼图渲染
    function renderPieSVG(data, total) {
        let svg = &#39;&lt;svg viewBox="0 0 100 100" class="w-full h-full"&gt;&#39;;
        let startAngle = 0;
        data.forEach(function(item) {
            const angle = (item.value / total) * 360;
            const endAngle = startAngle + angle;
            const x1 = 50 + 40 * Math.cos((startAngle - 90) * Math.PI / 180);
            const y1 = 50 + 40 * Math.sin((startAngle - 90) * Math.PI / 180);
            const x2 = 50 + 40 * Math.cos((endAngle - 90) * Math.PI / 180);
            const y2 = 50 + 40 * Math.sin((endAngle - 90) * Math.PI / 180);
            const largeArc = angle > 180 ? 1 : 0;
            svg += &#39;&lt;path d="M50,50 L&#39; + x1 + &#39;,&#39; + y1 + &#39; A40,40 0 &#39; + largeArc + &#39;,1 &#39; + x2 + &#39;,&#39; + y2 + &#39; Z" fill="&#39; + item.color + &#39;"/&gt;&#39;;
            startAngle = endAngle;
        });
        svg += &#39;&lt;/svg&gt;&#39;;
        return svg;
    }

    // 2. 关系类型分布饼状图
    function renderRelationTypePie(container, edges) {
        const typeCount = {};
        edges.forEach(function(e) {
            const type = e.type || &#39;关联&#39;;
            typeCount[type] = (typeCount[type] || 0) + 1;
        });
        
        const colors = [&#39;#6366f1&#39;, &#39;#8b5cf6&#39;, &#39;#ec4899&#39;, &#39;#f43f5e&#39;, &#39;#f97316&#39;, &#39;#eab308&#39;, &#39;#22c55e&#39;, &#39;#14b8a6&#39;];
        const data = Object.entries(typeCount).map(function(entry, i) {
            return { name: entry[0], value: entry[1], color: colors[i % colors.length] };
        });
        
        if (data.length === 0) {
            container.innerHTML = &#39;&lt;div class="flex items-center justify-center h-full text-base-content/50"&gt;暂无关系数据&lt;/div&gt;&#39;;
            return;
        }
        
        const total = edges.length;
        let html = &#39;&lt;div class="flex flex-col h-full p-3 overflow-hidden"&gt;&#39;;
        html += &#39;&lt;div class="flex items-center justify-center mb-2"&gt;&#39;;
        html += &#39;&lt;div class="w-24 h-24 flex-shrink-0"&gt;&#39;;
        html += renderPieSVG(data, total);
        html += &#39;&lt;/div&gt;&#39;;
        html += &#39;&lt;/div&gt;&#39;;
        html += &#39;&lt;div class="flex flex-wrap gap-x-3 gap-y-1 justify-center overflow-y-auto"&gt;&#39;;
        data.forEach(function(item) {
            const percent = ((item.value / total) * 100).toFixed(1);
            html += &#39;&lt;div class="flex items-center gap-1 text-xs whitespace-nowrap"&gt;&#39;;
            html += &#39;&lt;div class="w-2 h-2 rounded-full flex-shrink-0" style="background-color: &#39; + item.color + &#39;;"&gt;&lt;/div&gt;&#39;;
            html += &#39;&lt;span&gt;&#39; + item.name + &#39;&lt;/span&gt;&#39;;
            html += &#39;&lt;span class="text-base-content/50"&gt;&#39; + item.value + &#39;(&#39; + percent + &#39;%)&lt;/span&gt;&#39;;
            html += &#39;&lt;/div&gt;&#39;;
        });
        html += &#39;&lt;/div&gt;&#39;;
        html += &#39;&lt;/div&gt;&#39;;
        container.innerHTML = html;
    }

    // 3. 核心节点排行榜
    function renderCoreNodes(container, nodes) {
        const sorted = [...nodes].sort(function(a, b) {
            return (b.totalDegree || 0) - (a.totalDegree || 0);
        }).slice(0, 10);
        
        if (sorted.length === 0) {
            container.innerHTML = &#39;&lt;div class="flex items-center justify-center h-full text-base-content/50"&gt;暂无节点数据&lt;/div&gt;&#39;;
            return;
        }
        
        const maxDegree = sorted[0].totalDegree || 1;
        let html = &#39;&lt;div class="p-4 overflow-y-auto h-full"&gt;&#39;;
        html += &#39;&lt;div class="text-xs text-base-content/50 mb-2"&gt;按连接数排序 (Top 10)&lt;/div&gt;&#39;;
        sorted.forEach(function(n, i) {
            const degree = n.totalDegree || 0;
            const percent = (degree / maxDegree) * 100;
            html += &#39;&lt;div class="flex items-center gap-2 mb-2"&gt;&#39;;
            html += &#39;&lt;span class="w-5 text-xs text-base-content/50"&gt;&#39; + (i + 1) + &#39;&lt;/span&gt;&#39;;
            html += &#39;&lt;div class="flex-1"&gt;&#39;;
            html += &#39;&lt;div class="flex justify-between text-xs mb-1"&gt;&#39;;
            html += &#39;&lt;span class="truncate max-w-[120px]"&gt;&#39; + (n.name || &#39;未命名&#39;) + &#39;&lt;/span&gt;&#39;;
            html += &#39;&lt;span class="text-base-content/50"&gt;&#39; + degree + &#39;&lt;/span&gt;&#39;;
            html += &#39;&lt;/div&gt;&#39;;
            html += &#39;&lt;div class="h-1.5 bg-base-200 rounded-full overflow-hidden"&gt;&#39;;
            html += &#39;&lt;div class="h-full bg-primary rounded-full" style="width: &#39; + percent + &#39;%"&gt;&lt;/div&gt;&#39;;
            html += &#39;&lt;/div&gt;&#39;;
            html += &#39;&lt;/div&gt;&#39;;
            html += &#39;&lt;/div&gt;&#39;;
        });
        html += &#39;&lt;/div&gt;&#39;;
        container.innerHTML = html;
    }

    // 4. 图谱基础统计
    function renderStats(container, nodes, edges) {
        const nodeCount = nodes.length;
        const edgeCount = edges.length;
        const avgDegree = nodeCount > 0 ? ((edgeCount * 2) / nodeCount).toFixed(1) : 0;
        const typeCount = new Set(nodes.map(function(n) { return n.type || &#39;默认&#39;; })).size;
        
        let html = &#39;&lt;div class="grid grid-cols-2 gap-4 p-4 h-full content-center"&gt;&#39;;
        html += &#39;&lt;div class="bg-base-200 rounded-lg p-3 text-center"&gt;&#39;;
        html += &#39;&lt;div class="text-2xl font-bold text-primary"&gt;&#39; + nodeCount + &#39;&lt;/div&gt;&#39;;
        html += &#39;&lt;div class="text-xs text-base-content/50"&gt;节点数量&lt;/div&gt;&#39;;
        html += &#39;&lt;/div&gt;&#39;;
        html += &#39;&lt;div class="bg-base-200 rounded-lg p-3 text-center"&gt;&#39;;
        html += &#39;&lt;div class="text-2xl font-bold text-secondary"&gt;&#39; + edgeCount + &#39;&lt;/div&gt;&#39;;
        html += &#39;&lt;div class="text-xs text-base-content/50"&gt;关系数量&lt;/div&gt;&#39;;
        html += &#39;&lt;/div&gt;&#39;;
        html += &#39;&lt;div class="bg-base-200 rounded-lg p-3 text-center"&gt;&#39;;
        html += &#39;&lt;div class="text-2xl font-bold text-accent"&gt;&#39; + avgDegree + &#39;&lt;/div&gt;&#39;;
        html += &#39;&lt;div class="text-xs text-base-content/50"&gt;平均度数&lt;/div&gt;&#39;;
        html += &#39;&lt;/div&gt;&#39;;
        html += &#39;&lt;div class="bg-base-200 rounded-lg p-3 text-center"&gt;&#39;;
        html += &#39;&lt;div class="text-2xl font-bold text-info"&gt;&#39; + typeCount + &#39;&lt;/div&gt;&#39;;
        html += &#39;&lt;div class="text-xs text-base-content/50"&gt;节点类型&lt;/div&gt;&#39;;
        html += &#39;&lt;/div&gt;&#39;;
        html += &#39;&lt;/div&gt;&#39;;
        container.innerHTML = html;
    }

    // 5. 图谱缩略图
    function renderThumbnail(container) {
        const nodes = currentGraphData.nodes || [];
        const edges = currentGraphData.edges || [];
        
        if (nodes.length === 0) {
            container.innerHTML = &#39;&lt;div class="flex items-center justify-center h-full text-base-content/50"&gt;暂无图谱数据&lt;/div&gt;&#39;;
            return;
        }
        
        const width = 300, height = 200;
        const nodePositions = {};
        const centerX = width / 2, centerY = height / 2;
        const radius = Math.min(width, height) / 2 - 20;
        
        nodes.forEach(function(n, i) {
            const angle = (2 * Math.PI * i) / nodes.length;
            nodePositions[n.nodeId] = {
                x: centerX + radius * Math.cos(angle),
                y: centerY + radius * Math.sin(angle)
            };
        });
        
        let svg = &#39;&lt;svg viewBox="0 0 &#39; + width + &#39; &#39; + height + &#39;" class="w-full h-full"&gt;&#39;;
        
        edges.forEach(function(e) {
            const src = nodePositions[e.sourceNodeId];
            const tgt = nodePositions[e.targetNodeId];
            if (src &amp;&amp; tgt) {
                svg += &#39;&lt;line x1="&#39; + src.x + &#39;" y1="&#39; + src.y + &#39;" x2="&#39; + tgt.x + &#39;" y2="&#39; + tgt.y + &#39;" stroke="#6b7280" stroke-width="0.5" opacity="0.5"/&gt;&#39;;
            }
        });
        
        nodes.forEach(function(n) {
            const pos = nodePositions[n.nodeId];
            const color = getNodeColor(n.type || &#39;default&#39;);
            svg += &#39;&lt;circle cx="&#39; + pos.x + &#39;" cy="&#39; + pos.y + &#39;" r="4" fill="&#39; + color + &#39;"/&gt;&#39;;
        });
        
        svg += &#39;&lt;/svg&gt;&#39;;
        container.innerHTML = &#39;&lt;div class="p-2 h-full"&gt;&#39; + svg + &#39;&lt;/div&gt;&#39;;
    }

    // Initialize chart display
    function initializeChart() {
        currentChartType = &#39;nodeTypePie&#39;;
        document.getElementById(&#39;selectedChartType&#39;).textContent = chartTypes[currentChartType].name;
        renderChart(currentChartType);
    }

    // Graph initialization
    function initializeGraph() {
        // Use real data if available, otherwise show placeholder
        setTimeout(() => {
            const canvas = document.getElementById(&#39;graphCanvas&#39;);
            
            if (currentGraphData.nodes &amp;&amp; currentGraphData.nodes.length > 0) {
                renderGraphFromData();
            } else if (!currentGraphData.id) {
                // No graph ID, show demo graph
                canvas.innerHTML = `
                    <div class="absolute inset-0 flex items-center justify-center">
                        <div class="text-center">
                            <div class="w-16 h-16 bg-warning/20 rounded-full flex items-center justify-center mb-4 mx-auto">
                                <span class="iconify text-warning" data-icon="heroicons:exclamation-triangle" data-width="32"></span>
                            </div>
                            <p class="text-base-content font-medium">未指定图谱</p>
                            <p class="text-sm text-base-content/70 mt-2">请从图谱列表选择一个图谱查看</p>
                            <button class="btn btn-primary btn-sm mt-4" onclick="navigateTo(&#39;graph_list_page&#39;)">浏览图谱</button>
                        </div>
                    </div>
                `;
            } else {
            canvas.innerHTML = `
                <div class="absolute inset-0 flex items-center justify-center">
                    <div class="text-center">
                        <div class="w-16 h-16 bg-primary/20 rounded-full flex items-center justify-center mb-4 mx-auto">
                            <span class="iconify text-primary" data-icon="heroicons:cpu-chip" data-width="32"></span>
                        </div>
                        <p class="text-base-content font-medium">图谱加载完成</p>
                            <p class="text-sm text-base-content/70 mt-2">该图谱暂无节点数据</p>
                    </div>
                </div>
            `;
            }
        }, 500);
    }

    // Render graph from real data
    function renderGraphFromData() {
        const canvas = document.getElementById(&#39;graphCanvas&#39;);
        const nodes = currentGraphData.nodes || [];
        const edges = currentGraphData.edges || [];
        
        if (nodes.length === 0) {
            canvas.innerHTML = `
                <div class="absolute inset-0 flex items-center justify-center">
                    <div class="text-center">
                        <p class="text-base-content/70">该图谱暂无节点数据</p>
                    </div>
                </div>
            `;
            return;
        }

        canvas.innerHTML = &#39;&#39;;
        
        // Calculate positions using hierarchical radial layout
        const width = canvas.clientWidth || 800;
        const height = canvas.clientHeight || 600;
        const centerX = width / 2;
        const centerY = height / 2;
        
        // 构建邻接表并计算每个节点的连接数
        const adjacencyList = {};
        const connectionCount = {};
        nodes.forEach(n =&gt; {
            adjacencyList[n.nodeId] = [];
            connectionCount[n.nodeId] = 0;
        });
        edges.forEach(edge =&gt; {
            if (adjacencyList[edge.sourceNodeId]) {
                adjacencyList[edge.sourceNodeId].push(edge.targetNodeId);
                connectionCount[edge.sourceNodeId]++;
            }
            if (adjacencyList[edge.targetNodeId]) {
                adjacencyList[edge.targetNodeId].push(edge.sourceNodeId);
                connectionCount[edge.targetNodeId]++;
            }
        });
        
        // 找出所有连通分量
        const allVisited = new Set();
        const components = [];
        
        nodes.forEach(n =&gt; {
            if (allVisited.has(n.nodeId)) return;
            
            // BFS找出该连通分量的所有节点
            const component = [];
            const queue = [n.nodeId];
            allVisited.add(n.nodeId);
            
            while (queue.length &gt; 0) {
                const nodeId = queue.shift();
                component.push(nodeId);
                (adjacencyList[nodeId] || []).forEach(neighbor =&gt; {
                    if (!allVisited.has(neighbor)) {
                        allVisited.add(neighbor);
                        queue.push(neighbor);
                    }
                });
            }
            
            // 找出该分量中连接度最高的节点作为中心
            let centerNodeId = component[0];
            let maxConn = 0;
            component.forEach(nodeId =&gt; {
                if (connectionCount[nodeId] &gt; maxConn) {
                    maxConn = connectionCount[nodeId];
                    centerNodeId = nodeId;
                }
            });
            
            components.push({ nodes: component, center: centerNodeId, size: component.length });
        });
        
        // 按大小排序，大的分量放前面
        components.sort((a, b) =&gt; b.size - a.size);
        
        // 根据分量数量和大小计算布局区域
        const nodePositions = {};
        const componentCount = components.length;
        const totalNodes = nodes.length;
        
        // 区分大分量（>=5节点）和小分量（<5节点）
        const largeComps = components.filter(c =&gt; c.size &gt;= 5);
        const smallComps = components.filter(c =&gt; c.size &lt; 5);
        
        // 大分量按权重水平分配主区域（如果有小分量，主区域只占上部分）
        const componentAreas = [];
        const largeWeights = largeComps.map(c =&gt; Math.sqrt(c.size));
        const largeTotalWeight = largeWeights.reduce((a, b) =&gt; a + b, 0) || 1;
        
        // 如果有小分量，主区域高度缩小，给下方留空间
        const mainAreaHeight = smallComps.length > 0 ? height * 0.7 : height;
        const mainAreaCenterY = smallComps.length > 0 ? mainAreaHeight / 2 : height / 2;
        
        let currentX = 0;
        largeComps.forEach((comp, idx) =&gt; {
            const ratio = largeWeights[idx] / largeTotalWeight;
            const compWidth = width * ratio;
            componentAreas.push({
                x: currentX + compWidth / 2,
                y: mainAreaCenterY,
                w: compWidth,
                h: mainAreaHeight
            });
            currentX += compWidth;
        });
        
        // 小分量的节点在主图下方弧形分布（凸起向下，动态计算间距）
        const smallNodeIds = smallComps.flatMap(c =&gt; c.nodes);
        if (smallNodeIds.length &gt; 0) {
            // 弧线中心在主分量下方
            const arcCenterX = width / 2;
            const arcY = mainAreaHeight + 40;  // 弧线顶部位置（主分量区域底部+间距）
            
            // 根据节点数量动态计算弧线参数
            const minSpacing = 60;  // 节点最小间距
            const totalWidth = Math.min(width * 0.8, smallNodeIds.length * minSpacing);  // 弧线跨度
            const arcRadius = totalWidth / 2 + 50;  // 弧线半径
            const arcCenterY = arcY - arcRadius;  // 圆心在弧线上方
            
            // 计算弧度范围
            const halfChord = totalWidth / 2;
            const halfAngle = Math.asin(Math.min(halfChord / arcRadius, 1));
            const startAngle = Math.PI / 2 - halfAngle;
            const angleStep = smallNodeIds.length > 1 ? (2 * halfAngle) / (smallNodeIds.length - 1) : 0;
            
            smallNodeIds.forEach((nodeId, idx) =&gt; {
                const angle = startAngle + angleStep * idx;
                const node = nodes.find(n =&gt; n.nodeId === nodeId);
                nodePositions[nodeId] = {
                    x: arcCenterX + arcRadius * Math.cos(angle),
                    y: arcCenterY + arcRadius * Math.sin(angle),
                    ...node
                };
            });
        }
        
        // 只为大分量独立布局（小分量已弧形分布）
        largeComps.forEach((comp, compIndex) =&gt; {
            const area = componentAreas[compIndex];
            if (!area) return;
            const compCenterX = area.x;
            const compCenterY = area.y;
            const cellWidth = area.w;
            const cellHeight = area.h;
            
            // BFS构建该分量的层级
            const nodesByLevel = {};
            const nodeLevels = {};
            const visited = new Set();
            const bfsQueue = [{ nodeId: comp.center, level: 0 }];
            visited.add(comp.center);
            
            while (bfsQueue.length &gt; 0) {
                const { nodeId, level } = bfsQueue.shift();
                if (!nodesByLevel[level]) nodesByLevel[level] = [];
                nodesByLevel[level].push(nodeId);
                nodeLevels[nodeId] = level;
                
                (adjacencyList[nodeId] || []).forEach(neighbor =&gt; {
                    if (!visited.has(neighbor) &amp;&amp; comp.nodes.includes(neighbor)) {
                        visited.add(neighbor);
                        bfsQueue.push({ nodeId: neighbor, level: level + 1 });
                    }
                });
            }
            
            // 记录父节点
            const parentMap = {};
            edges.forEach(edge =&gt; {
                const srcLevel = nodeLevels[edge.sourceNodeId];
                const tgtLevel = nodeLevels[edge.targetNodeId];
                if (srcLevel !== undefined &amp;&amp; tgtLevel !== undefined) {
                    if (srcLevel &lt; tgtLevel) parentMap[edge.targetNodeId] = edge.sourceNodeId;
                    else if (tgtLevel &lt; srcLevel) parentMap[edge.sourceNodeId] = edge.targetNodeId;
                }
            });
            
            const maxLevel = Math.max(...Object.keys(nodesByLevel).map(Number), 0);
            
            // 使用自适应布局参数
            const layoutParams = calculateLayoutParams(comp.nodes.length, cellWidth, cellHeight, maxLevel);
            const baseLayerGap = layoutParams.layerGap;
            
            // 为该分量的每个层级分配位置
            Object.keys(nodesByLevel).sort((a, b) =&gt; Number(a) - Number(b)).forEach(levelStr =&gt; {
                const level = parseInt(levelStr);
                const nodesAtLevel = nodesByLevel[level];
                
                if (level === 0) {
                    const node = nodes.find(n =&gt; n.nodeId === comp.center);
                    nodePositions[comp.center] = { x: compCenterX, y: compCenterY, ...node };
                } else {
                    // 层级半径：确保第一层有足够距离，后续层级递增
                    const radius = baseLayerGap * level;
                    
                    const nodesByParent = {};
                    nodesAtLevel.forEach(nodeId =&gt; {
                        const parent = parentMap[nodeId] || &#39;_root&#39;;
                        if (!nodesByParent[parent]) nodesByParent[parent] = [];
                        nodesByParent[parent].push(nodeId);
                    });
                    
                    if (level === 1) {
                        const angleStep = (2 * Math.PI) / nodesAtLevel.length;
                        const startAngle = -Math.PI / 2;
                        nodesAtLevel.forEach((nodeId, index) =&gt; {
                            const angle = startAngle + angleStep * index;
                            const node = nodes.find(n =&gt; n.nodeId === nodeId);
                            nodePositions[nodeId] = {
                                x: compCenterX + radius * Math.cos(angle),
                                y: compCenterY + radius * Math.sin(angle),
                                ...node
                            };
                        });
                    } else {
                        const totalChildren = nodesAtLevel.length;
                        Object.keys(nodesByParent).forEach(parentId =&gt; {
                            const children = nodesByParent[parentId];
                            const parentPos = nodePositions[parentId];
                            
                            if (!parentPos) {
                                children.forEach((nodeId, idx) =&gt; {
                                    const angle = (idx / totalChildren) * 2 * Math.PI;
                                    const node = nodes.find(n =&gt; n.nodeId === nodeId);
                                    nodePositions[nodeId] = {
                                        x: compCenterX + radius * Math.cos(angle),
                                        y: compCenterY + radius * Math.sin(angle),
                                        ...node
                                    };
                                });
                                return;
                            }
                            
                            const parentAngle = Math.atan2(parentPos.y - compCenterY, parentPos.x - compCenterX);
                            const minAnglePerChild = 0.25;
                            const requiredAngle = children.length * minAnglePerChild;
                            const spreadAngle = Math.min(Math.PI * 1.2, Math.max(requiredAngle, Math.PI / 4));
                            const childAngleStep = children.length &gt; 1 ? spreadAngle / (children.length - 1) : 0;
                            const childStartAngle = parentAngle - spreadAngle / 2;
                            
                            children.forEach((nodeId, idx) =&gt; {
                                const childAngle = children.length &gt; 1 ? childStartAngle + childAngleStep * idx : parentAngle;
                                const node = nodes.find(n =&gt; n.nodeId === nodeId);
                                nodePositions[nodeId] = {
                                    x: compCenterX + radius * Math.cos(childAngle),
                                    y: compCenterY + radius * Math.sin(childAngle),
                                    ...node
                                };
                            });
                        });
                    }
                }
            });
        });
        
        // Create SVG container
        const svg = document.createElementNS(&#39;http://www.w3.org/2000/svg&#39;, &#39;svg&#39;);
        svg.setAttribute(&#39;width&#39;, &#39;100%&#39;);
        svg.setAttribute(&#39;height&#39;, &#39;100%&#39;);
        svg.style.position = &#39;absolute&#39;;
        svg.style.top = &#39;0&#39;;
        svg.style.left = &#39;0&#39;;

        // 添加箭头定义
        const defs = document.createElementNS(&#39;http://www.w3.org/2000/svg&#39;, &#39;defs&#39;);
        const marker = document.createElementNS(&#39;http://www.w3.org/2000/svg&#39;, &#39;marker&#39;);
        marker.setAttribute(&#39;id&#39;, &#39;arrowhead&#39;);
        marker.setAttribute(&#39;markerWidth&#39;, &#39;10&#39;);
        marker.setAttribute(&#39;markerHeight&#39;, &#39;7&#39;);
        marker.setAttribute(&#39;refX&#39;, &#39;9&#39;);
        marker.setAttribute(&#39;refY&#39;, &#39;3.5&#39;);
        marker.setAttribute(&#39;orient&#39;, &#39;auto&#39;);
        const polygon = document.createElementNS(&#39;http://www.w3.org/2000/svg&#39;, &#39;polygon&#39;);
        polygon.setAttribute(&#39;points&#39;, &#39;0 0, 10 3.5, 0 7&#39;);
        polygon.setAttribute(&#39;fill&#39;, &#39;#1E3A8A&#39;);
        marker.appendChild(polygon);
        defs.appendChild(marker);
        svg.appendChild(defs);

        // Draw edges first (so nodes appear on top)
        console.log(&#39;Drawing edges:&#39;, edges.length, &#39;edges&#39;);
        console.log(&#39;Node positions keys:&#39;, Object.keys(nodePositions));
        
        let edgesDrawn = 0;
        edges.forEach((edge, index) => {
            console.log(`Edge ${index}:`, edge.sourceNodeId, &#39;->&#39;, edge.targetNodeId);
            const fromNode = nodePositions[edge.sourceNodeId];
            const toNode = nodePositions[edge.targetNodeId];
            
            if (fromNode &amp;&amp; toNode) {
                // 计算边的终点（缩短一点以避免穿过节点圆心）
                const dx = toNode.x - fromNode.x;
                const dy = toNode.y - fromNode.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const nodeRadius = 14;
                
                // 调整起点和终点，避免穿过节点
                const startX = fromNode.x + (dx / dist) * nodeRadius;
                const startY = fromNode.y + (dy / dist) * nodeRadius;
                const endX = toNode.x - (dx / dist) * (nodeRadius + 5);
                const endY = toNode.y - (dy / dist) * (nodeRadius + 5);
            
            const line = document.createElementNS(&#39;http://www.w3.org/2000/svg&#39;, &#39;line&#39;);
                line.setAttribute(&#39;x1&#39;, startX);
                line.setAttribute(&#39;y1&#39;, startY);
                line.setAttribute(&#39;x2&#39;, endX);
                line.setAttribute(&#39;y2&#39;, endY);
            line.setAttribute(&#39;class&#39;, &#39;graph-edge&#39;);
                // 内联样式确保边可见
                line.style.stroke = &#39;#1E3A8A&#39;;
                line.style.strokeWidth = &#39;2px&#39;;
                line.style.opacity = &#39;0.7&#39;;
                line.setAttribute(&#39;marker-end&#39;, &#39;url(#arrowhead)&#39;);
                line.setAttribute(&#39;data-edge-type&#39;, edge.type || &#39;关联&#39;);
                line.setAttribute(&#39;data-edge-source&#39;, edge.sourceNodeId);
                line.setAttribute(&#39;data-edge-target&#39;, edge.targetNodeId);
            svg.appendChild(line);
                
                // 添加关系类型标签
                const midX = (fromNode.x + toNode.x) / 2;
                const midY = (fromNode.y + toNode.y) / 2;
                const label = document.createElementNS(&#39;http://www.w3.org/2000/svg&#39;, &#39;text&#39;);
                label.setAttribute(&#39;x&#39;, midX);
                label.setAttribute(&#39;y&#39;, midY - 8);
                label.setAttribute(&#39;text-anchor&#39;, &#39;middle&#39;);
                label.setAttribute(&#39;class&#39;, &#39;edge-label&#39;);
                label.setAttribute(&#39;data-label-source&#39;, edge.sourceNodeId);
                label.setAttribute(&#39;data-label-target&#39;, edge.targetNodeId);
                label.style.fontSize = &#39;11px&#39;;
                label.style.fill = &#39;#1E3A8A&#39;;
                label.style.fontWeight = &#39;500&#39;;
                label.textContent = edge.type || &#39;&#39;;
                svg.appendChild(label);
                
                edgesDrawn++;
            } else {
                console.warn(`Edge ${index}: Could not find nodes - from:`, fromNode, &#39;to:&#39;, toNode);
            }
        });
        console.log(&#39;Edges actually drawn:&#39;, edgesDrawn);

        // Draw nodes
        Object.values(nodePositions).forEach(node => {
            const circle = document.createElementNS(&#39;http://www.w3.org/2000/svg&#39;, &#39;circle&#39;);
            circle.setAttribute(&#39;cx&#39;, node.x);
            circle.setAttribute(&#39;cy&#39;, node.y);
            circle.setAttribute(&#39;r&#39;, 14);
            circle.setAttribute(&#39;class&#39;, &#39;graph-node&#39;);
            circle.setAttribute(&#39;fill&#39;, getNodeColor(node.type || &#39;default&#39;));
            circle.setAttribute(&#39;data-node-id&#39;, node.nodeId);
            circle.setAttribute(&#39;data-node-type&#39;, node.type || &#39;default&#39;);
            circle.style.cursor = &#39;grab&#39;;
            
            // 添加拖动事件
            circle.addEventListener(&#39;mousedown&#39;, (e) => startDrag(e, node.nodeId));
            svg.appendChild(circle);

            // Add text label
            const text = document.createElementNS(&#39;http://www.w3.org/2000/svg&#39;, &#39;text&#39;);
            text.setAttribute(&#39;x&#39;, node.x);
            text.setAttribute(&#39;y&#39;, node.y + 28);
            text.setAttribute(&#39;text-anchor&#39;, &#39;middle&#39;);
            text.setAttribute(&#39;class&#39;, &#39;node-label text-xs fill-current text-base-content font-medium&#39;);
            text.setAttribute(&#39;data-label-for&#39;, node.nodeId);
            text.textContent = node.name || &#39;未命名&#39;;
            svg.appendChild(text);
        });

        // 添加拖动事件监听器到 canvas（而非 SVG）
        canvas.addEventListener(&#39;mousemove&#39;, onDrag);
        canvas.addEventListener(&#39;mouseup&#39;, endDrag);
        canvas.addEventListener(&#39;mouseleave&#39;, endDrag);

        canvas.appendChild(svg);
        
        // 保存节点位置数据
        currentGraphData.nodePositions = nodePositions;
    }
    
    // ==================== 节点拖动功能（高性能版） ====================
    
    let dragging = {
        active: false,
        nodeId: null,
        offsetX: 0,
        offsetY: 0,
        moved: false,
        // 缓存元素引用，避免重复查询 DOM
        nodeEl: null,
        labelEl: null,
        edges: [],      // { edge, targetX, targetY, isSource, labelEl }
        canvasRect: null,
        rafId: null,
        targetX: 0,
        targetY: 0
    };
    
    const NODE_RADIUS = 14;
    
    // 开始拖动
    function startDrag(event, nodeId) {
        event.preventDefault();
        event.stopPropagation();
        
        const canvas = document.getElementById(&#39;graphCanvas&#39;);
        const nodeEl = document.querySelector(`[data-node-id="${nodeId}"]`);
        if (!canvas || !nodeEl) return;
        
        const rect = canvas.getBoundingClientRect();
        const mouseX = event.clientX - rect.left;
        const mouseY = event.clientY - rect.top;
        const nodeCX = parseFloat(nodeEl.getAttribute(&#39;cx&#39;));
        const nodeCY = parseFloat(nodeEl.getAttribute(&#39;cy&#39;));
        
        // 预先缓存所有需要更新的元素
        const edges = [];
        
        // 以该节点为起点的边
        document.querySelectorAll(`[data-edge-source="${nodeId}"]`).forEach(edge =&gt; {
            const targetId = edge.getAttribute(&#39;data-edge-target&#39;);
            const targetEl = document.querySelector(`[data-node-id="${targetId}"]`);
            if (targetEl) {
                edges.push({
                    edge: edge,
                    targetX: parseFloat(targetEl.getAttribute(&#39;cx&#39;)),
                    targetY: parseFloat(targetEl.getAttribute(&#39;cy&#39;)),
                    isSource: true,
                    labelEl: document.querySelector(`[data-label-source="${nodeId}"][data-label-target="${targetId}"]`)
                });
            }
        });
        
        // 以该节点为终点的边
        document.querySelectorAll(`[data-edge-target="${nodeId}"]`).forEach(edge =&gt; {
            const sourceId = edge.getAttribute(&#39;data-edge-source&#39;);
            const sourceEl = document.querySelector(`[data-node-id="${sourceId}"]`);
            if (sourceEl) {
                edges.push({
                    edge: edge,
                    targetX: parseFloat(sourceEl.getAttribute(&#39;cx&#39;)),
                    targetY: parseFloat(sourceEl.getAttribute(&#39;cy&#39;)),
                    isSource: false,
                    labelEl: document.querySelector(`[data-label-source="${sourceId}"][data-label-target="${nodeId}"]`)
                });
            }
        });
        
        dragging = {
            active: true,
            nodeId: nodeId,
            offsetX: mouseX - nodeCX,
            offsetY: mouseY - nodeCY,
            moved: false,
            nodeEl: nodeEl,
            labelEl: document.querySelector(`[data-label-for="${nodeId}"]`),
            edges: edges,
            canvasRect: rect,
            rafId: null,
            targetX: nodeCX,
            targetY: nodeCY
        };
        
        nodeEl.style.cursor = &#39;grabbing&#39;;
    }
    
    // 拖动中 - 只记录目标位置，由 RAF 执行实际更新
    function onDrag(event) {
        if (!dragging.active) return;
        
        const mouseX = event.clientX - dragging.canvasRect.left;
        const mouseY = event.clientY - dragging.canvasRect.top;
        
        dragging.targetX = mouseX - dragging.offsetX;
        dragging.targetY = mouseY - dragging.offsetY;
        dragging.moved = true;
        
        // 使用 RAF 批量更新，避免重复渲染
        if (!dragging.rafId) {
            dragging.rafId = requestAnimationFrame(updateDragPosition);
        }
    }
    
    // 实际更新位置（在 RAF 中执行）
    function updateDragPosition() {
        if (!dragging.active) {
            dragging.rafId = null;
            return;
        }
        
        const x = dragging.targetX;
        const y = dragging.targetY;
        
        // 更新节点
        dragging.nodeEl.setAttribute(&#39;cx&#39;, x);
        dragging.nodeEl.setAttribute(&#39;cy&#39;, y);
        
        // 更新标签
        if (dragging.labelEl) {
            dragging.labelEl.setAttribute(&#39;x&#39;, x);
            dragging.labelEl.setAttribute(&#39;y&#39;, y + 28);
        }
        
        // 更新所有边
        for (const e of dragging.edges) {
            let x1, y1, x2, y2;
            if (e.isSource) {
                x1 = x; y1 = y;
                x2 = e.targetX; y2 = e.targetY;
            } else {
                x1 = e.targetX; y1 = e.targetY;
                x2 = x; y2 = y;
            }
            
            const dx = x2 - x1;
            const dy = y2 - y1;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist > 0) {
                const nx = dx / dist;
                const ny = dy / dist;
                e.edge.setAttribute(&#39;x1&#39;, x1 + nx * NODE_RADIUS);
                e.edge.setAttribute(&#39;y1&#39;, y1 + ny * NODE_RADIUS);
                e.edge.setAttribute(&#39;x2&#39;, x2 - nx * (NODE_RADIUS + 5));
                e.edge.setAttribute(&#39;y2&#39;, y2 - ny * (NODE_RADIUS + 5));
                
                if (e.labelEl) {
                    e.labelEl.setAttribute(&#39;x&#39;, (x1 + x2) / 2);
                    e.labelEl.setAttribute(&#39;y&#39;, (y1 + y2) / 2 - 8);
                }
            }
        }
        
        // 更新数据
        if (currentGraphData.nodePositions?.[dragging.nodeId]) {
            currentGraphData.nodePositions[dragging.nodeId].x = x;
            currentGraphData.nodePositions[dragging.nodeId].y = y;
        }
        
        dragging.rafId = null;
    }
    
    // 结束拖动
    function endDrag(event) {
        if (!dragging.active) return;
        
        if (dragging.nodeEl) {
            dragging.nodeEl.style.cursor = &#39;grab&#39;;
        }
        
        // 取消未执行的 RAF
        if (dragging.rafId) {
            cancelAnimationFrame(dragging.rafId);
        }
        
        // 如果没有移动，触发点击选择
        if (!dragging.moved &amp;&amp; dragging.nodeId) {
            const nodes = currentGraphData.nodes || [];
            const nodeData = nodes.find(n =&gt; n.nodeId === dragging.nodeId);
            if (nodeData) {
                const nodeInfo = {
                    id: nodeData.nodeId,
                    nodeId: nodeData.nodeId,
                    label: nodeData.name,
                    name: nodeData.name,
                    type: nodeData.type || &#39;default&#39;,
                    description: nodeData.description
                };
                selectNode(nodeInfo);
            }
        }
        
        dragging = {
            active: false, nodeId: null, offsetX: 0, offsetY: 0, moved: false,
            nodeEl: null, labelEl: null, edges: [], canvasRect: null, rafId: null,
            targetX: 0, targetY: 0
        };
    }

    // 节点类型颜色映射（预定义 + 动态生成）
    const nodeTypeColors = {};
    const predefinedColors = {
        // 常用类型预定义颜色
        &#39;概念&#39;: &#39;#3B82F6&#39;,      // 蓝色
        &#39;concept&#39;: &#39;#3B82F6&#39;,
        &#39;算法&#39;: &#39;#8B5CF6&#39;,      // 紫色
        &#39;algorithm&#39;: &#39;#8B5CF6&#39;,
        &#39;应用&#39;: &#39;#10B981&#39;,      // 绿色
        &#39;application&#39;: &#39;#10B981&#39;,
        &#39;工具&#39;: &#39;#F59E0B&#39;,      // 橙色
        &#39;tool&#39;: &#39;#F59E0B&#39;,
        &#39;人物&#39;: &#39;#EC4899&#39;,      // 粉色
        &#39;person&#39;: &#39;#EC4899&#39;,
        &#39;组织&#39;: &#39;#6366F1&#39;,      // 靛蓝
        &#39;organization&#39;: &#39;#6366F1&#39;,
        &#39;地点&#39;: &#39;#14B8A6&#39;,      // 青色
        &#39;location&#39;: &#39;#14B8A6&#39;,
        &#39;事件&#39;: &#39;#EF4444&#39;,      // 红色
        &#39;event&#39;: &#39;#EF4444&#39;,
        &#39;技术&#39;: &#39;#0EA5E9&#39;,      // 天蓝
        &#39;technology&#39;: &#39;#0EA5E9&#39;,
        &#39;理论&#39;: &#39;#A855F7&#39;,      // 紫罗兰
        &#39;theory&#39;: &#39;#A855F7&#39;,
        &#39;方法&#39;: &#39;#22C55E&#39;,      // 亮绿
        &#39;method&#39;: &#39;#22C55E&#39;,
        &#39;默认&#39;: &#39;#64748B&#39;,      // 灰色
        &#39;default&#39;: &#39;#64748B&#39;
    };
    
    // 用于动态生成颜色的色相列表
    const dynamicHues = [210, 280, 150, 30, 330, 180, 0, 45, 260, 120, 300, 60];
    let dynamicColorIndex = 0;
    
    // Get node color based on type
    function getNodeColor(type) {
        if (!type) return predefinedColors[&#39;default&#39;];
        
        const typeLower = type.toLowerCase();
        
        // 检查预定义颜色
        if (predefinedColors[type]) return predefinedColors[type];
        if (predefinedColors[typeLower]) return predefinedColors[typeLower];
        
        // 检查已缓存的动态颜色
        if (nodeTypeColors[type]) return nodeTypeColors[type];
        
        // 生成新的动态颜色（基于色相环，保证区分度）
        const hue = dynamicHues[dynamicColorIndex % dynamicHues.length];
        dynamicColorIndex++;
        const color = `hsl(${hue}, 65%, 55%)`;
        nodeTypeColors[type] = color;
        
        return color;
    }

    // Node selection handler
    function selectNode(node) {
        currentGraphData.selectedNode = node;
        
        // 记录当前选中的节点ID（用于邻居深度功能）
        currentSelectedNodeId = node.id;
        
        // 清除所有节点的选中样式
        document.querySelectorAll(&#39;.graph-node&#39;).forEach(n =&gt; {
            n.classList.remove(&#39;selected&#39;);
            n.style.stroke = &#39;&#39;;
            n.style.strokeWidth = &#39;&#39;;
            n.style.filter = &#39;&#39;;
        });
        
        // 设置当前节点的选中样式
        const nodeEl = document.querySelector(`[data-node-id="${node.id}"]`);
        if (nodeEl) {
            nodeEl.classList.add(&#39;selected&#39;);
            nodeEl.style.stroke = &#39;var(--color-primary)&#39;;
            nodeEl.style.strokeWidth = &#39;3px&#39;;
            nodeEl.style.filter = &#39;drop-shadow(0 2px 4px rgba(30, 58, 138, 0.3))&#39;;
        }
        
        // Update right sidebar detail panel
        if (window.updateNodeDetailPanel) {
            window.updateNodeDetailPanel(node);
        }
    }

    // Update node details panel (legacy - now using right sidebar)
    function updateNodeDetails(node) {
        // 此函数保留用于兼容，实际显示在右侧详情栏
    }

    // 从实际边数据获取相关节点
    function getRelatedNodesFromData(nodeId) {
        const edges = currentGraphData.edges || [];
        const nodes = currentGraphData.nodes || [];
        const relatedIds = new Set();
        
        edges.forEach(edge => {
            if (edge.sourceNodeId === nodeId) {
                relatedIds.add(edge.targetNodeId);
    }
            if (edge.targetNodeId === nodeId) {
                relatedIds.add(edge.sourceNodeId);
            }
        });
        
        return nodes.filter(n => relatedIds.has(n.nodeId)).map(n => ({
            id: n.nodeId,
            name: n.name || &#39;未命名&#39;
        }));
    }

    // 获取节点连接数
    function getNodeConnectionCount(nodeId) {
        const edges = currentGraphData.edges || [];
        return edges.filter(edge => 
            edge.sourceNodeId === nodeId || edge.targetNodeId === nodeId
        ).length;
    }

    // 高亮指定节点
    window.highlightNode = function(nodeId) {
        clearSearchHighlight();
        const node = document.querySelector(`[data-node-id="${nodeId}"]`);
        if (node) {
            node.style.stroke = &#39;var(--color-warning)&#39;;
            node.style.strokeWidth = &#39;4px&#39;;
            
            // 滚动到该节点（如果需要）
            node.scrollIntoView({ behavior: &#39;smooth&#39;, block: &#39;center&#39; });
        }
    };

    // Search functionality
    function setupSearchFunctionality() {
        const searchInput = document.getElementById(&#39;graphSearchInput&#39;);
        searchInput.addEventListener(&#39;input&#39;, handleSearch);
        searchInput.addEventListener(&#39;keypress&#39;, function(e) {
            if (e.key === &#39;Enter&#39;) {
                handleSearch();
            }
        });
    }

    // 更新搜索类型筛选下拉框
    function updateSearchTypeFilter() {
        const nodes = currentGraphData.nodes || [];
        const types = [...new Set(nodes.map(n =&gt; n.type || &#39;未分类&#39;))];
        
        const typeSelect = document.getElementById(&#39;searchTypeFilter&#39;);
        if (typeSelect) {
            typeSelect.innerHTML = `
                &lt;option value=""&gt;全部类型&lt;/option&gt;
                &lt;optgroup label="按类型筛选"&gt;
                    ${types.map(t =&gt; `&lt;option value="type_${t}"&gt;${t}&lt;/option&gt;`).join(&#39;&#39;)}
                &lt;/optgroup&gt;
                &lt;optgroup label="排序方式"&gt;
                    &lt;option value="sort_degree"&gt;按度数排序&lt;/option&gt;
                &lt;/optgroup&gt;
            `;
        }
    }

    function handleSearch() {
        const query = document.getElementById(&#39;graphSearchInput&#39;).value.toLowerCase().trim();
        const typeFilter = document.getElementById(&#39;searchTypeFilter&#39;)?.value || &#39;&#39;;
        const resultsPanel = document.getElementById(&#39;searchResultsPanel&#39;);
        const resultsList = document.getElementById(&#39;searchResultList&#39;);
        const resultCount = document.getElementById(&#39;searchResultCount&#39;);
        
        if (!query &amp;&amp; !typeFilter) {
            clearSearchHighlight();
            restoreAllElementsOpacity();
            if (resultsPanel) resultsPanel.classList.add(&#39;hidden&#39;);
            // 空搜索时还原最初的节点布局
            if (originalLayout) {
                animateToNewLayout(originalLayout, null, new Set(), []);
                originalLayout = null;
            }
            return;
        }

        // 搜索实际节点数据
        const nodes = currentGraphData.nodes || [];
        let results = nodes;
        
        // 按类型筛选
        if (typeFilter) {
            results = results.filter(node =&gt; (node.type || &#39;未分类&#39;) === typeFilter);
        }
        
        // 按关键词搜索
        if (query) {
            results = results.filter(node =&gt; {
                const name = (node.name || &#39;&#39;).toLowerCase();
                return name.includes(query);
            });
        }
        
        results = results.map(node =&gt; ({
            id: node.nodeId,
            label: node.name,
            type: node.type
        }));

        // 如果只有一个结果，显示以该节点为中心的图谱视图
        if (results.length === 1) {
            showCenteredGraphView(results[0].id);
        } else {
            highlightSearchResults(results);
        }
        
        // 显示搜索结果面板
        if (resultsPanel &amp;&amp; resultsList &amp;&amp; resultCount) {
            resultCount.textContent = results.length;
            if (results.length &gt; 0) {
                resultsList.innerHTML = results.map(node =&gt; `
                    &lt;div class="flex items-center gap-2 p-2 hover:bg-base-200 rounded cursor-pointer text-xs" onclick="highlightAndSelectNode(&#39;${node.id}&#39;)"&gt;
                        &lt;span class="flex-1 truncate"&gt;${node.label || &#39;未命名&#39;}&lt;/span&gt;
                        &lt;span class="badge badge-ghost badge-xs"&gt;${node.type || &#39;未分类&#39;}&lt;/span&gt;
                    &lt;/div&gt;
                `).join(&#39;&#39;);
                resultsPanel.classList.remove(&#39;hidden&#39;);
            } else {
                resultsList.innerHTML = &#39;&lt;div class="text-xs text-base-content/50 text-center py-2"&gt;未找到匹配结果&lt;/div&gt;&#39;;
                resultsPanel.classList.remove(&#39;hidden&#39;);
            }
        }
    }
    
    // 保存原始布局位置
    let originalLayout = null;
    
    // 自适应布局参数计算 - 根据节点数量动态调整间距
    function calculateLayoutParams(nodeCount, canvasWidth, canvasHeight, maxLevel) {
        const minNodeSpacing = 60;  // 节点最小间距
        const nodesPerLevel = nodeCount / Math.max(maxLevel, 1);
        
        // 根据每层节点数计算所需周长和半径
        const requiredCircumference = nodesPerLevel * minNodeSpacing;
        const minRadiusForSpacing = requiredCircumference / (2 * Math.PI);
        
        // 画布可用的最大半径
        const maxAvailableRadius = Math.min(canvasWidth, canvasHeight) / 2 - 40;
        
        // 最优半径：确保间距足够
        const optimalRadius = Math.max(minRadiusForSpacing, 100);
        
        // 层级间距：确保最小80px，根据层数合理分配
        const layerGap = Math.max(80, Math.min(optimalRadius / Math.max(maxLevel, 1), 120));
        
        return {
            optimalRadius: optimalRadius,
            layerGap: layerGap,
            maxRadius: maxAvailableRadius
        };
    }
    
    // 以指定节点为中心重新布局图谱
    function showCenteredGraphView(centerNodeId) {
        const edges = currentGraphData.edges || [];
        const nodes = currentGraphData.nodes || [];
        const canvas = document.getElementById(&#39;graphCanvas&#39;);
        
        if (!canvas) return;
        
        // 保存原始布局（如果还没保存）
        if (!originalLayout) {
            originalLayout = {};
            document.querySelectorAll(&#39;.graph-node&#39;).forEach(nodeEl =&gt; {
                const nodeId = nodeEl.getAttribute(&#39;data-node-id&#39;);
                originalLayout[nodeId] = {
                    x: parseFloat(nodeEl.getAttribute(&#39;cx&#39;)),
                    y: parseFloat(nodeEl.getAttribute(&#39;cy&#39;))
                };
            });
        }
        
        // 构建邻接表
        const adjacencyList = {};
        nodes.forEach(n =&gt; adjacencyList[n.nodeId] = []);
        edges.forEach(edge =&gt; {
            if (adjacencyList[edge.sourceNodeId]) {
                adjacencyList[edge.sourceNodeId].push(edge.targetNodeId);
            }
            if (adjacencyList[edge.targetNodeId]) {
                adjacencyList[edge.targetNodeId].push(edge.sourceNodeId);
            }
        });
        
        // BFS 找到所有连通的节点，并记录层级（距离）
        const nodesByLevel = {}; // level -> [nodeIds]
        const nodeLevels = {};   // nodeId -> level
        const visited = new Set();
        const queue = [{ nodeId: centerNodeId, level: 0 }];
        visited.add(centerNodeId);
        
        while (queue.length > 0) {
            const { nodeId, level } = queue.shift();
            
            if (!nodesByLevel[level]) nodesByLevel[level] = [];
            nodesByLevel[level].push(nodeId);
            nodeLevels[nodeId] = level;
            
            (adjacencyList[nodeId] || []).forEach(neighbor =&gt; {
                if (!visited.has(neighbor)) {
                    visited.add(neighbor);
                    queue.push({ nodeId: neighbor, level: level + 1 });
                }
            });
        }
        
        // 找出不连通的节点
        const disconnectedNodes = nodes
            .map(n =&gt; n.nodeId)
            .filter(id =&gt; !visited.has(id));
        
        // 获取画布中心
        const centerX = canvas.clientWidth / 2;
        const centerY = canvas.clientHeight / 2;
        
        // 计算新的布局位置
        const newPositions = {};
        const maxLevel = Math.max(...Object.keys(nodesByLevel).map(Number), 0);
        
        // 使用自适应布局参数
        const layoutParams = calculateLayoutParams(nodes.length, canvas.clientWidth, canvas.clientHeight, maxLevel);
        const baseLayerGap = layoutParams.layerGap;
        const maxRadius = layoutParams.maxRadius;
        
        // 记录每个节点的父节点（用于扇形布局）
        const parentMap = {};
        edges.forEach(edge =&gt; {
            const srcLevel = nodeLevels[edge.sourceNodeId];
            const tgtLevel = nodeLevels[edge.targetNodeId];
            if (srcLevel !== undefined &amp;&amp; tgtLevel !== undefined) {
                if (srcLevel &lt; tgtLevel) {
                    parentMap[edge.targetNodeId] = edge.sourceNodeId;
                } else if (tgtLevel &lt; srcLevel) {
                    parentMap[edge.sourceNodeId] = edge.targetNodeId;
                }
            }
        });
        
        // 按层级分配位置 - 使用改进的扇形径向布局
        Object.keys(nodesByLevel).sort((a, b) =&gt; Number(a) - Number(b)).forEach(levelStr =&gt; {
            const level = parseInt(levelStr);
            const nodesAtLevel = nodesByLevel[level];
            
            if (level === 0) {
                // 中心节点
                newPositions[centerNodeId] = { x: centerX, y: centerY };
            } else {
                // 层级半径：直接线性关系
                const radius = baseLayerGap * level;
                
                // 按父节点分组
                const nodesByParent = {};
                nodesAtLevel.forEach(nodeId =&gt; {
                    const parent = parentMap[nodeId] || &#39;_root&#39;;
                    if (!nodesByParent[parent]) nodesByParent[parent] = [];
                    nodesByParent[parent].push(nodeId);
                });
                
                // 计算每个父节点分配的角度范围
                const parents = Object.keys(nodesByParent);
                const totalChildren = nodesAtLevel.length;
                
                if (level === 1) {
                    // 第一层：均匀分布在圆周上
                    const angleStep = (2 * Math.PI) / nodesAtLevel.length;
                    const startAngle = -Math.PI / 2; // 从顶部开始
                    nodesAtLevel.forEach((nodeId, index) =&gt; {
                        const angle = startAngle + angleStep * index;
                        newPositions[nodeId] = {
                            x: centerX + radius * Math.cos(angle),
                            y: centerY + radius * Math.sin(angle)
                        };
                    });
                } else {
                    // 更深层：围绕父节点的方向排列
                    let currentAngleOffset = 0;
                    parents.forEach(parentId =&gt; {
                        const children = nodesByParent[parentId];
                        const parentPos = newPositions[parentId];
                        
                        if (!parentPos) {
                            // 父节点位置未知，使用默认角度
                            const fallbackAngle = currentAngleOffset;
                            children.forEach((nodeId, idx) =&gt; {
                                const childAngle = fallbackAngle + (idx - (children.length - 1) / 2) * 0.3;
                                newPositions[nodeId] = {
                                    x: centerX + radius * Math.cos(childAngle),
                                    y: centerY + radius * Math.sin(childAngle)
                                };
                            });
                            currentAngleOffset += children.length * 0.35;
                            return;
                        }
                        
                        // 计算父节点相对于中心的角度
                        const parentAngle = Math.atan2(parentPos.y - centerY, parentPos.x - centerX);
                        
                        // 子节点围绕父节点方向分散排列 - 根据子节点数量动态计算扩散角度
                        const minAnglePerChild = 0.25;  // 每个子节点最小占用约15度
                        const requiredAngle = children.length * minAnglePerChild;
                        const spreadAngle = Math.min(Math.PI * 1.2, Math.max(requiredAngle, Math.PI / 4));
                        const childAngleStep = children.length > 1 ? spreadAngle / (children.length - 1) : 0;
                        const childStartAngle = parentAngle - spreadAngle / 2;
                        
                        children.forEach((nodeId, idx) =&gt; {
                            const childAngle = children.length > 1 
                                ? childStartAngle + childAngleStep * idx 
                                : parentAngle;
                            newPositions[nodeId] = {
                                x: centerX + radius * Math.cos(childAngle),
                                y: centerY + radius * Math.sin(childAngle)
                            };
                        });
                    });
                }
            }
        });
        
        // 不连通的节点保持原位置不变（只变暗，不移动）
        // 不需要为它们计算新位置
        
        // 动画过渡到新位置
        animateToNewLayout(newPositions, centerNodeId, visited, disconnectedNodes);
        
        // 选中中心节点并更新详情面板
        const centerNode = nodes.find(n =&gt; n.nodeId === centerNodeId);
        if (centerNode) {
            const nodeInfo = {
                id: centerNode.nodeId,
                nodeId: centerNode.nodeId,
                label: centerNode.name,
                name: centerNode.name,
                type: centerNode.type || &#39;default&#39;,
                description: centerNode.description
            };
            selectNode(nodeInfo);
            
            // 确保右侧详情面板更新
            if (window.updateNodeDetailPanel) {
                window.updateNodeDetailPanel(nodeInfo);
            }
        }
        
        const connectedCount = visited.size - 1;
        const msg = disconnectedNodes.length > 0 
            ? `以"${centerNode?.name || &#39;节点&#39;}"为中心，${connectedCount} 个连通节点，${disconnectedNodes.length} 个不连通`
            : `以"${centerNode?.name || &#39;节点&#39;}"为中心，共 ${connectedCount} 个连通节点`;
        window.showNotification(msg, &#39;info&#39;);
    }
    
    // 动画过渡到新布局
    function animateToNewLayout(newPositions, centerNodeId, connectedIds, disconnectedIds) {
        const duration = 600; // 动画时长 ms
        const startTime = performance.now();
        
        // 记录起始位置
        const startPositions = {};
        document.querySelectorAll(&#39;.graph-node&#39;).forEach(nodeEl =&gt; {
            const nodeId = nodeEl.getAttribute(&#39;data-node-id&#39;);
            startPositions[nodeId] = {
                x: parseFloat(nodeEl.getAttribute(&#39;cx&#39;)),
                y: parseFloat(nodeEl.getAttribute(&#39;cy&#39;))
            };
        });
        
        function animate(currentTime) {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            // 使用 easeOutCubic 缓动函数
            const eased = 1 - Math.pow(1 - progress, 3);
            
            // 更新每个节点的位置
            Object.keys(newPositions).forEach(nodeId =&gt; {
                const start = startPositions[nodeId];
                const end = newPositions[nodeId];
                if (!start || !end) return;
                
                const currentX = start.x + (end.x - start.x) * eased;
                const currentY = start.y + (end.y - start.y) * eased;
                
                // 更新节点
                const nodeEl = document.querySelector(`[data-node-id="${nodeId}"]`);
                if (nodeEl) {
                    nodeEl.setAttribute(&#39;cx&#39;, currentX);
                    nodeEl.setAttribute(&#39;cy&#39;, currentY);
                }
                
                // 更新标签
                const labelEl = document.querySelector(`[data-label-for="${nodeId}"]`);
                if (labelEl) {
                    labelEl.setAttribute(&#39;x&#39;, currentX);
                    labelEl.setAttribute(&#39;y&#39;, currentY + 28);
                }
                
                // 更新数据
                if (currentGraphData.nodePositions?.[nodeId]) {
                    currentGraphData.nodePositions[nodeId].x = currentX;
                    currentGraphData.nodePositions[nodeId].y = currentY;
                }
            });
            
            // 更新所有边
            updateAllEdges();
            
            if (progress &lt; 1) {
                requestAnimationFrame(animate);
            } else {
                // 动画结束，应用样式
                applyFocusStyles(centerNodeId, connectedIds, disconnectedIds || []);
            }
        }
        
        requestAnimationFrame(animate);
    }
    
    // 更新所有边的位置
    function updateAllEdges() {
        const radius = 14;
        
        // 先缓存所有节点位置
        const nodePositionsMap = {};
        document.querySelectorAll(&#39;.graph-node&#39;).forEach(node =&gt; {
            const nodeId = node.getAttribute(&#39;data-node-id&#39;);
            nodePositionsMap[nodeId] = {
                x: parseFloat(node.getAttribute(&#39;cx&#39;)),
                y: parseFloat(node.getAttribute(&#39;cy&#39;))
            };
        });
        
        // 更新边
        document.querySelectorAll(&#39;.graph-edge&#39;).forEach(edge =&gt; {
            const sourceId = edge.getAttribute(&#39;data-edge-source&#39;);
            const targetId = edge.getAttribute(&#39;data-edge-target&#39;);
            
            const sourcePos = nodePositionsMap[sourceId];
            const targetPos = nodePositionsMap[targetId];
            
            if (sourcePos &amp;&amp; targetPos) {
                const x1 = sourcePos.x;
                const y1 = sourcePos.y;
                const x2 = targetPos.x;
                const y2 = targetPos.y;
                
                const dx = x2 - x1;
                const dy = y2 - y1;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 0) {
                    const nx = dx / dist;
                    const ny = dy / dist;
                    edge.setAttribute(&#39;x1&#39;, x1 + nx * radius);
                    edge.setAttribute(&#39;y1&#39;, y1 + ny * radius);
                    edge.setAttribute(&#39;x2&#39;, x2 - nx * (radius + 5));
                    edge.setAttribute(&#39;y2&#39;, y2 - ny * (radius + 5));
                }
            }
        });
        
        // 单独更新所有边标签
        document.querySelectorAll(&#39;.edge-label&#39;).forEach(label =&gt; {
            const sourceId = label.getAttribute(&#39;data-label-source&#39;);
            const targetId = label.getAttribute(&#39;data-label-target&#39;);
            
            const sourcePos = nodePositionsMap[sourceId];
            const targetPos = nodePositionsMap[targetId];
            
            if (sourcePos &amp;&amp; targetPos) {
                label.setAttribute(&#39;x&#39;, (sourcePos.x + targetPos.x) / 2);
                label.setAttribute(&#39;y&#39;, (sourcePos.y + targetPos.y) / 2 - 8);
            }
        });
    }
    
    // 应用聚焦样式
    function applyFocusStyles(centerNodeId, connectedIds, disconnectedIds) {
        const disconnectedSet = new Set(disconnectedIds);
        
        // 节点样式
        document.querySelectorAll(&#39;.graph-node&#39;).forEach(nodeEl =&gt; {
            const nodeId = nodeEl.getAttribute(&#39;data-node-id&#39;);
            if (nodeId === centerNodeId) {
                // 中心节点 - 红色高亮
                nodeEl.style.stroke = &#39;#ef4444&#39;;
                nodeEl.style.strokeWidth = &#39;4px&#39;;
                nodeEl.style.filter = &#39;drop-shadow(0 0 12px #ef4444)&#39;;
                nodeEl.style.opacity = &#39;1&#39;;
            } else if (disconnectedSet.has(nodeId)) {
                // 不连通节点 - 变暗
                nodeEl.style.stroke = &#39;&#39;;
                nodeEl.style.strokeWidth = &#39;&#39;;
                nodeEl.style.filter = &#39;grayscale(80%)&#39;;
                nodeEl.style.opacity = &#39;0.2&#39;;
            } else {
                // 连通节点 - 正常显示
                nodeEl.style.stroke = &#39;&#39;;
                nodeEl.style.strokeWidth = &#39;&#39;;
                nodeEl.style.filter = &#39;&#39;;
                nodeEl.style.opacity = &#39;1&#39;;
            }
        });
        
        // 标签样式
        document.querySelectorAll(&#39;.node-label&#39;).forEach(label =&gt; {
            const nodeId = label.getAttribute(&#39;data-label-for&#39;);
            if (nodeId === centerNodeId) {
                label.style.opacity = &#39;1&#39;;
                label.style.fontWeight = &#39;700&#39;;
            } else if (disconnectedSet.has(nodeId)) {
                label.style.opacity = &#39;0.15&#39;;
                label.style.fontWeight = &#39;&#39;;
            } else {
                label.style.opacity = &#39;1&#39;;
                label.style.fontWeight = &#39;&#39;;
            }
        });
        
        // 边样式 - 只有两端都是连通节点的边才正常显示
        document.querySelectorAll(&#39;.graph-edge&#39;).forEach(edge =&gt; {
            const sourceId = edge.getAttribute(&#39;data-edge-source&#39;);
            const targetId = edge.getAttribute(&#39;data-edge-target&#39;);
            const bothConnected = connectedIds.has(sourceId) &amp;&amp; connectedIds.has(targetId);
            
            if (bothConnected) {
                // 与中心直接相连的边特殊高亮
                if (sourceId === centerNodeId || targetId === centerNodeId) {
                    edge.style.stroke = &#39;#ef4444&#39;;
                    edge.style.strokeWidth = &#39;2.5px&#39;;
                    edge.style.opacity = &#39;0.9&#39;;
                } else {
                    edge.style.stroke = &#39;#1E3A8A&#39;;
                    edge.style.strokeWidth = &#39;2px&#39;;
                    edge.style.opacity = &#39;0.7&#39;;
                }
            } else {
                // 涉及不连通节点的边变暗
                edge.style.stroke = &#39;#999&#39;;
                edge.style.strokeWidth = &#39;1px&#39;;
                edge.style.opacity = &#39;0.1&#39;;
            }
        });
        
        // 边标签样式
        document.querySelectorAll(&#39;.edge-label&#39;).forEach(label =&gt; {
            const sourceId = label.getAttribute(&#39;data-label-source&#39;);
            const targetId = label.getAttribute(&#39;data-label-target&#39;);
            const bothConnected = connectedIds.has(sourceId) &amp;&amp; connectedIds.has(targetId);
            label.style.opacity = bothConnected ? &#39;1&#39; : &#39;0.1&#39;;
        });
    }
    
    // 恢复所有元素的透明度
    function restoreAllElementsOpacity() {
        document.querySelectorAll(&#39;.graph-node&#39;).forEach(node =&gt; {
            node.style.opacity = &#39;&#39;;
            node.style.filter = &#39;&#39;;
            if (!node.classList.contains(&#39;selected&#39;)) {
                node.style.stroke = &#39;&#39;;
                node.style.strokeWidth = &#39;&#39;;
            }
        });
        document.querySelectorAll(&#39;.node-label&#39;).forEach(label =&gt; {
            label.style.opacity = &#39;&#39;;
            label.style.fontWeight = &#39;&#39;;
        });
        document.querySelectorAll(&#39;.graph-edge&#39;).forEach(edge =&gt; {
            edge.style.opacity = &#39;&#39;;
            edge.style.stroke = &#39;#1E3A8A&#39;;
            edge.style.strokeWidth = &#39;2px&#39;;
        });
        document.querySelectorAll(&#39;.edge-label&#39;).forEach(label =&gt; {
            label.style.opacity = &#39;&#39;;
        });
    }
    
    // 重置图谱视图（恢复原始布局）
    window.resetGraphView = function() {
        // 清空搜索框
        const searchInput = document.getElementById(&#39;graphSearchInput&#39;);
        const typeFilter = document.getElementById(&#39;searchTypeFilter&#39;);
        if (searchInput) searchInput.value = &#39;&#39;;
        if (typeFilter) typeFilter.value = &#39;&#39;;
        
        // 隐藏搜索结果面板
        const resultsPanel = document.getElementById(&#39;searchResultsPanel&#39;);
        if (resultsPanel) resultsPanel.classList.add(&#39;hidden&#39;);
        
        // 如果有保存的原始布局，恢复它
        if (originalLayout) {
            animateToOriginalLayout();
        } else {
            restoreAllElementsOpacity();
            clearSearchHighlight();
        }
        
        window.showNotification(&#39;已恢复原始图谱布局&#39;, &#39;info&#39;);
    };
    
    // 动画恢复到原始布局
    function animateToOriginalLayout() {
        if (!originalLayout) return;
        
        const duration = 400;
        const startTime = performance.now();
        
        // 记录当前位置
        const currentPositions = {};
        document.querySelectorAll(&#39;.graph-node&#39;).forEach(nodeEl =&gt; {
            const nodeId = nodeEl.getAttribute(&#39;data-node-id&#39;);
            currentPositions[nodeId] = {
                x: parseFloat(nodeEl.getAttribute(&#39;cx&#39;)),
                y: parseFloat(nodeEl.getAttribute(&#39;cy&#39;))
            };
        });
        
        function animate(currentTime) {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const eased = 1 - Math.pow(1 - progress, 3);
            
            Object.keys(originalLayout).forEach(nodeId =&gt; {
                const start = currentPositions[nodeId];
                const end = originalLayout[nodeId];
                if (!start || !end) return;
                
                const x = start.x + (end.x - start.x) * eased;
                const y = start.y + (end.y - start.y) * eased;
                
                const nodeEl = document.querySelector(`[data-node-id="${nodeId}"]`);
                if (nodeEl) {
                    nodeEl.setAttribute(&#39;cx&#39;, x);
                    nodeEl.setAttribute(&#39;cy&#39;, y);
                }
                
                const labelEl = document.querySelector(`[data-label-for="${nodeId}"]`);
                if (labelEl) {
                    labelEl.setAttribute(&#39;x&#39;, x);
                    labelEl.setAttribute(&#39;y&#39;, y + 28);
                }
                
                if (currentGraphData.nodePositions?.[nodeId]) {
                    currentGraphData.nodePositions[nodeId].x = x;
                    currentGraphData.nodePositions[nodeId].y = y;
                }
            });
            
            updateAllEdges();
            
            if (progress &lt; 1) {
                requestAnimationFrame(animate);
            } else {
                // 动画结束，恢复样式
                restoreAllElementsOpacity();
                clearSearchHighlight();
                originalLayout = null; // 清除保存的布局
            }
        }
        
        requestAnimationFrame(animate);
    }

    function highlightSearchResults(results) {
        clearSearchHighlight();
        restoreAllElementsOpacity();
        results.forEach(result =&gt; {
            const node = document.querySelector(`[data-node-id="${result.id}"]`);
            if (node) {
                node.style.stroke = &#39;var(--color-warning)&#39;;
                node.style.strokeWidth = &#39;3px&#39;;
            }
        });
    }

    function clearSearchHighlight() {
        document.querySelectorAll(&#39;.graph-node&#39;).forEach(node =&gt; {
            if (!node.classList.contains(&#39;selected&#39;)) {
                node.style.stroke = &#39;&#39;;
                node.style.strokeWidth = &#39;&#39;;
                node.style.filter = &#39;&#39;;
            }
        });
    }

    // View controls setup
    function setupViewControls() {
        const depthRange = document.getElementById(&#39;depthRange&#39;);
        if (depthRange) {
            depthRange.addEventListener(&#39;input&#39;, function() {
                const value = parseInt(this.value);
                // 如果有选中的节点，则高亮其N层邻居
                if (currentSelectedNodeId) {
                    const direction = document.getElementById(&#39;neighborDirectionSelect&#39;)?.value || &#39;all&#39;;
                    highlightNeighborsByDepth(currentSelectedNodeId, value, direction);
                }
            });
        }
    }
    
    // 当前选中的节点ID
    let currentSelectedNodeId = null;
    
    // 高亮节点的N层邻居（支持方向：all/out/in）
    function highlightNeighborsByDepth(nodeId, depth, direction) {
        direction = direction || &#39;all&#39;;
        const nodes = currentGraphData.nodes || [];
        const edges = currentGraphData.edges || [];
        
        // 根据方向构建邻接表
        const adjacencyList = {};
        nodes.forEach(n =&gt; adjacencyList[n.nodeId] = []);
        edges.forEach(edge =&gt; {
            if (direction === &#39;all&#39; || direction === &#39;out&#39;) {
                // 出边：source -> target
                if (adjacencyList[edge.sourceNodeId]) {
                    adjacencyList[edge.sourceNodeId].push(edge.targetNodeId);
                }
            }
            if (direction === &#39;all&#39; || direction === &#39;in&#39;) {
                // 入边：target -> source
                if (adjacencyList[edge.targetNodeId]) {
                    adjacencyList[edge.targetNodeId].push(edge.sourceNodeId);
                }
            }
        });
        
        // BFS获取N层内的所有邻居
        const visitedNodes = new Set([nodeId]);
        let currentLevel = [nodeId];
        
        for (let d = 0; d &lt; depth; d++) {
            const nextLevel = [];
            for (const n of currentLevel) {
                for (const neighbor of (adjacencyList[n] || [])) {
                    if (!visitedNodes.has(neighbor)) {
                        visitedNodes.add(neighbor);
                        nextLevel.push(neighbor);
                    }
                }
            }
            currentLevel = nextLevel;
        }
        
        // 收集需要高亮的边
        const highlightedEdges = new Set();
        edges.forEach(edge =&gt; {
            if (visitedNodes.has(edge.sourceNodeId) &amp;&amp; visitedNodes.has(edge.targetNodeId)) {
                highlightedEdges.add(`${edge.sourceNodeId}-${edge.targetNodeId}`);
            }
        });
        
        // 更新节点透明度
        document.querySelectorAll(&#39;.graph-node&#39;).forEach(node =&gt; {
            const nId = node.getAttribute(&#39;data-node-id&#39;);
            node.style.opacity = visitedNodes.has(nId) ? &#39;1&#39; : &#39;0.2&#39;;
        });
        
        // 更新节点标签透明度
        document.querySelectorAll(&#39;[data-label-for]&#39;).forEach(label =&gt; {
            const nId = label.getAttribute(&#39;data-label-for&#39;);
            label.style.opacity = visitedNodes.has(nId) ? &#39;1&#39; : &#39;0.2&#39;;
        });
        
        // 更新边透明度
        document.querySelectorAll(&#39;.graph-edge&#39;).forEach(edge =&gt; {
            const source = edge.getAttribute(&#39;data-edge-source&#39;);
            const target = edge.getAttribute(&#39;data-edge-target&#39;);
            const isHighlighted = highlightedEdges.has(`${source}-${target}`) || highlightedEdges.has(`${target}-${source}`);
            edge.style.opacity = isHighlighted ? &#39;0.7&#39; : &#39;0.1&#39;;
        });
        
        // 更新边标签透明度
        document.querySelectorAll(&#39;.edge-label&#39;).forEach(label =&gt; {
            const source = label.getAttribute(&#39;data-label-source&#39;);
            const target = label.getAttribute(&#39;data-label-target&#39;);
            const isHighlighted = highlightedEdges.has(`${source}-${target}`) || highlightedEdges.has(`${target}-${source}`);
            label.style.opacity = isHighlighted ? &#39;1&#39; : &#39;0.1&#39;;
        });
        
        const directionText = direction === &#39;all&#39; ? &#39;所有&#39; : (direction === &#39;out&#39; ? &#39;出边&#39; : &#39;入边&#39;);
        window.showNotification(`已显示 ${depth} 层${directionText}邻居，共 ${visitedNodes.size} 个节点`, &#39;info&#39;);
    }
    
    // 邻居方向改变时的处理函数
    function handleNeighborDirectionChange() {
        if (currentSelectedNodeId) {
            const depth = parseInt(document.getElementById(&#39;depthRange&#39;).value);
            const direction = document.getElementById(&#39;neighborDirectionSelect&#39;).value;
            highlightNeighborsByDepth(currentSelectedNodeId, depth, direction);
        }
    }
    window.handleNeighborDirectionChange = handleNeighborDirectionChange;
    
    // 节点排序查询
    window.handleNodeQuery = function(value) {
        if (!value) return;
        
        if (value === &#39;degree&#39;) {
            showNodesByDegree();
        }
        
        // 重置下拉框
        document.getElementById(&#39;nodeQuerySelect&#39;).value = &#39;&#39;;
    };
    
    // 显示按度数排序的节点列表
    function showNodesByDegree() {
        const nodes = currentGraphData.nodes || [];
        const edges = currentGraphData.edges || [];
        
        // 计算每个节点的度数
        const degreeMap = {};
        nodes.forEach(n =&gt; degreeMap[n.nodeId] = 0);
        edges.forEach(edge =&gt; {
            if (degreeMap[edge.sourceNodeId] !== undefined) degreeMap[edge.sourceNodeId]++;
            if (degreeMap[edge.targetNodeId] !== undefined) degreeMap[edge.targetNodeId]++;
        });
        
        // 按度数排序
        const sortedNodes = nodes.map(n =&gt; ({
            ...n,
            degree: degreeMap[n.nodeId] || 0
        })).sort((a, b) =&gt; b.degree - a.degree);
        
        // 显示结果
        const resultsPanel = document.getElementById(&#39;searchResultsPanel&#39;);
        const resultsList = document.getElementById(&#39;searchResultList&#39;);
        const resultCount = document.getElementById(&#39;searchResultCount&#39;);
        
        if (resultsPanel &amp;&amp; resultsList &amp;&amp; resultCount) {
            resultCount.textContent = sortedNodes.length;
            resultsList.innerHTML = sortedNodes.map(node =&gt; `
                &lt;div class="flex items-center justify-between gap-2 p-2 hover:bg-base-200 rounded cursor-pointer text-xs" onclick="highlightAndSelectNode(&#39;${node.nodeId}&#39;)"&gt;
                    &lt;span class="truncate"&gt;${node.name}&lt;/span&gt;
                    &lt;span class="badge badge-sm badge-primary"&gt;${node.degree}&lt;/span&gt;
                &lt;/div&gt;
            `).join(&#39;&#39;);
            resultsPanel.classList.remove(&#39;hidden&#39;);
        }
        
        window.showNotification(&#39;已按度数排序，点击节点可选中&#39;, &#39;info&#39;);
    }
    
    // 路径查询
    window.handlePathQuery = function(value) {
        if (!value) return;
        
        if (value === &#39;relation&#39; || value === &#39;shortest&#39;) {
            openPathQueryModal(value);
        }
        
        // 重置下拉框
        document.getElementById(&#39;pathQuerySelect&#39;).value = &#39;&#39;;
    };
    
    // 打开路径查询模态框
    function openPathQueryModal(queryType) {
        const typeNames = {
            &#39;relation&#39;: &#39;关系寻路&#39;,
            &#39;shortest&#39;: &#39;最短路径&#39;
        };
        
        // 创建模态框（如果不存在）
        let modal = document.getElementById(&#39;pathQueryModal&#39;);
        if (!modal) {
            modal = document.createElement(&#39;dialog&#39;);
            modal.id = &#39;pathQueryModal&#39;;
            modal.className = &#39;modal&#39;;
            document.body.appendChild(modal);
        }
        
        const nodes = currentGraphData.nodes || [];
        // 按字典序排列节点
        const sortedNodes = [...nodes].sort((a, b) =&gt; {
            const nameA = (a.name || &#39;&#39;).toLowerCase();
            const nameB = (b.name || &#39;&#39;).toLowerCase();
            return nameA.localeCompare(nameB, &#39;zh-CN&#39;);
        });
        // 使用 datalist 实现可输入搜索
        const nodeDatalistOptions = sortedNodes.map(n =&gt; `&lt;option value="${n.name}" data-node-id="${n.nodeId}"&gt;`).join(&#39;&#39;);
        
        modal.innerHTML = `
            &lt;div class="modal-box"&gt;
                &lt;h3 class="font-bold text-lg mb-4"&gt;${typeNames[queryType]}&lt;/h3&gt;
                &lt;div class="form-control mb-3"&gt;
                    &lt;label class="label"&gt;&lt;span class="label-text"&gt;起始节点&lt;/span&gt;&lt;/label&gt;
                    &lt;input type="text" id="pathStartNodeInput" list="pathStartNodeList" class="input input-bordered input-sm w-full" placeholder="输入或选择起始节点"&gt;
                    &lt;datalist id="pathStartNodeList"&gt;${nodeDatalistOptions}&lt;/datalist&gt;
                &lt;/div&gt;
                &lt;div class="form-control mb-4"&gt;
                    &lt;label class="label"&gt;&lt;span class="label-text"&gt;目标节点&lt;/span&gt;&lt;/label&gt;
                    &lt;input type="text" id="pathEndNodeInput" list="pathEndNodeList" class="input input-bordered input-sm w-full" placeholder="输入或选择目标节点"&gt;
                    &lt;datalist id="pathEndNodeList"&gt;${nodeDatalistOptions}&lt;/datalist&gt;
                &lt;/div&gt;
                &lt;div class="modal-action"&gt;
                    &lt;button class="btn btn-sm" onclick="document.getElementById(&#39;pathQueryModal&#39;).close()"&gt;取消&lt;/button&gt;
                    &lt;button class="btn btn-primary btn-sm" onclick="executePathQuery(&#39;${queryType}&#39;)"&gt;查询&lt;/button&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;form method="dialog" class="modal-backdrop"&gt;&lt;button&gt;close&lt;/button&gt;&lt;/form&gt;
        `;
        
        // 保存节点映射供查询使用
        window._pathQueryNodes = sortedNodes;
        
        modal.showModal();
    }
    
    // 执行路径查询
    window.executePathQuery = function(queryType) {
        const startName = document.getElementById(&#39;pathStartNodeInput&#39;).value.trim();
        const endName = document.getElementById(&#39;pathEndNodeInput&#39;).value.trim();
        
        if (!startName || !endName) {
            window.showNotification(&#39;请输入起始节点和目标节点&#39;, &#39;warning&#39;);
            return;
        }
        
        // 通过名称查找节点ID
        const nodes = window._pathQueryNodes || currentGraphData.nodes || [];
        const startNode = nodes.find(n =&gt; n.name === startName);
        const endNode = nodes.find(n =&gt; n.name === endName);
        
        if (!startNode) {
            window.showNotification(&#39;未找到起始节点: &#39; + startName, &#39;warning&#39;);
            return;
        }
        if (!endNode) {
            window.showNotification(&#39;未找到目标节点: &#39; + endName, &#39;warning&#39;);
            return;
        }
        
        const startId = startNode.nodeId;
        const endId = endNode.nodeId;
        
        if (startId === endId) {
            window.showNotification(&#39;起始节点和目标节点不能相同&#39;, &#39;warning&#39;);
            return;
        }
        
        document.getElementById(&#39;pathQueryModal&#39;).close();
        
        if (queryType === &#39;shortest&#39; || queryType === &#39;relation&#39;) {
            findShortestPath(startId, endId, queryType === &#39;relation&#39;);
        }
    };
    
    // BFS查找最短路径
    function findShortestPath(startId, endId, showRelations) {
        const edges = currentGraphData.edges || [];
        const nodes = currentGraphData.nodes || [];
        
        // 构建邻接表
        const adjacencyList = {};
        const edgeMap = {};
        nodes.forEach(n =&gt; adjacencyList[n.nodeId] = []);
        edges.forEach(edge =&gt; {
            if (adjacencyList[edge.sourceNodeId]) {
                adjacencyList[edge.sourceNodeId].push(edge.targetNodeId);
                edgeMap[`${edge.sourceNodeId}-${edge.targetNodeId}`] = edge;
            }
            if (adjacencyList[edge.targetNodeId]) {
                adjacencyList[edge.targetNodeId].push(edge.sourceNodeId);
                edgeMap[`${edge.targetNodeId}-${edge.sourceNodeId}`] = edge;
            }
        });
        
        // BFS
        const visited = new Set([startId]);
        const queue = [[startId]];
        let path = null;
        
        while (queue.length &gt; 0) {
            const currentPath = queue.shift();
            const currentNode = currentPath[currentPath.length - 1];
            
            if (currentNode === endId) {
                path = currentPath;
                break;
            }
            
            for (const neighbor of (adjacencyList[currentNode] || [])) {
                if (!visited.has(neighbor)) {
                    visited.add(neighbor);
                    queue.push([...currentPath, neighbor]);
                }
            }
        }
        
        if (path) {
            highlightPath(path, edgeMap, showRelations);
        } else {
            window.showNotification(&#39;未找到连接这两个节点的路径&#39;, &#39;warning&#39;);
        }
    }
    
    // 高亮路径
    function highlightPath(path, edgeMap, showRelations) {
        // 降低所有节点和边的透明度
        document.querySelectorAll(&#39;.graph-node&#39;).forEach(n =&gt; n.style.opacity = &#39;0.2&#39;);
        document.querySelectorAll(&#39;.graph-edge&#39;).forEach(e =&gt; e.style.opacity = &#39;0.1&#39;);
        document.querySelectorAll(&#39;.edge-label&#39;).forEach(l =&gt; l.style.opacity = &#39;0.1&#39;);
        document.querySelectorAll(&#39;[data-label-for]&#39;).forEach(l =&gt; l.style.opacity = &#39;0.2&#39;);
        
        // 高亮路径上的节点
        const pathNodeIds = new Set(path);
        document.querySelectorAll(&#39;.graph-node&#39;).forEach(node =&gt; {
            if (pathNodeIds.has(node.getAttribute(&#39;data-node-id&#39;))) {
                node.style.opacity = &#39;1&#39;;
            }
        });
        document.querySelectorAll(&#39;[data-label-for]&#39;).forEach(label =&gt; {
            if (pathNodeIds.has(label.getAttribute(&#39;data-label-for&#39;))) {
                label.style.opacity = &#39;1&#39;;
            }
        });
        
        // 高亮路径上的边
        const pathEdges = [];
        for (let i = 0; i &lt; path.length - 1; i++) {
            const edgeKey1 = `${path[i]}-${path[i+1]}`;
            const edgeKey2 = `${path[i+1]}-${path[i]}`;
            const edge = edgeMap[edgeKey1] || edgeMap[edgeKey2];
            if (edge) pathEdges.push(edge);
        }
        
        document.querySelectorAll(&#39;.graph-edge&#39;).forEach(edgeEl =&gt; {
            const source = edgeEl.getAttribute(&#39;data-edge-source&#39;);
            const target = edgeEl.getAttribute(&#39;data-edge-target&#39;);
            const isInPath = pathEdges.some(e =&gt; 
                (e.sourceNodeId === source &amp;&amp; e.targetNodeId === target) ||
                (e.sourceNodeId === target &amp;&amp; e.targetNodeId === source)
            );
            if (isInPath) {
                edgeEl.style.opacity = &#39;1&#39;;
                edgeEl.style.stroke = &#39;#3b82f6&#39;;
                edgeEl.style.strokeWidth = &#39;3&#39;;
            }
        });
        
        // 构建路径描述
        const nodes = currentGraphData.nodes || [];
        const nodeNameMap = {};
        nodes.forEach(n =&gt; nodeNameMap[n.nodeId] = n.name);
        
        let pathDesc = path.map(id =&gt; nodeNameMap[id] || id).join(&#39; → &#39;);
        if (showRelations) {
            pathDesc = &#39;&#39;;
            for (let i = 0; i &lt; path.length; i++) {
                pathDesc += nodeNameMap[path[i]] || path[i];
                if (i &lt; path.length - 1) {
                    const edge = pathEdges[i];
                    const relType = edge ? (edge.type || &#39;关联&#39;) : &#39;?&#39;;
                    pathDesc += ` -[${relType}]→ `;
                }
            }
        }
        
        window.showNotification(`路径: ${pathDesc}`, &#39;success&#39;);
    }
    
    // DFS查找所有路径
    function findAllPaths(startId, endId, maxDepth = 5) {
        const edges = currentGraphData.edges || [];
        const nodes = currentGraphData.nodes || [];
        
        // 构建邻接表
        const adjacencyList = {};
        nodes.forEach(n =&gt; adjacencyList[n.nodeId] = []);
        edges.forEach(edge =&gt; {
            if (adjacencyList[edge.sourceNodeId]) {
                adjacencyList[edge.sourceNodeId].push(edge.targetNodeId);
            }
            if (adjacencyList[edge.targetNodeId]) {
                adjacencyList[edge.targetNodeId].push(edge.sourceNodeId);
            }
        });
        
        const allPaths = [];
        const visited = new Set();
        
        function dfs(current, path) {
            if (path.length &gt; maxDepth) return;
            if (current === endId) {
                allPaths.push([...path]);
                return;
            }
            
            visited.add(current);
            for (const neighbor of (adjacencyList[current] || [])) {
                if (!visited.has(neighbor)) {
                    path.push(neighbor);
                    dfs(neighbor, path);
                    path.pop();
                }
            }
            visited.delete(current);
        }
        
        dfs(startId, [startId]);
        
        if (allPaths.length === 0) {
            window.showNotification(&#39;未找到连接这两个节点的路径&#39;, &#39;warning&#39;);
            return;
        }
        
        // 显示路径列表
        const nodeNameMap = {};
        nodes.forEach(n =&gt; nodeNameMap[n.nodeId] = n.name);
        
        const resultsPanel = document.getElementById(&#39;searchResultsPanel&#39;);
        const resultsList = document.getElementById(&#39;searchResultList&#39;);
        const resultCount = document.getElementById(&#39;searchResultCount&#39;);
        
        if (resultsPanel &amp;&amp; resultsList &amp;&amp; resultCount) {
            resultCount.textContent = allPaths.length;
            resultsList.innerHTML = allPaths.map((path, idx) =&gt; {
                const pathStr = path.map(id =&gt; nodeNameMap[id] || id).join(&#39; → &#39;);
                return `&lt;div class="p-2 hover:bg-base-200 rounded cursor-pointer text-xs" onclick="highlightPathByIndex(${idx})"&gt;
                    &lt;span class="font-medium"&gt;路径${idx + 1}:&lt;/span&gt; ${pathStr}
                &lt;/div&gt;`;
            }).join(&#39;&#39;);
            resultsPanel.classList.remove(&#39;hidden&#39;);
        }
        
        // 保存路径供高亮使用
        window._allPaths = allPaths;
        window._edgeMap = {};
        edges.forEach(edge =&gt; {
            window._edgeMap[`${edge.sourceNodeId}-${edge.targetNodeId}`] = edge;
            window._edgeMap[`${edge.targetNodeId}-${edge.sourceNodeId}`] = edge;
        });
        
        window.showNotification(`找到 ${allPaths.length} 条路径`, &#39;success&#39;);
    }
    
    // 按索引高亮路径
    window.highlightPathByIndex = function(idx) {
        if (window._allPaths &amp;&amp; window._allPaths[idx]) {
            highlightPath(window._allPaths[idx], window._edgeMap, false);
        }
    };

    // Entity type filters - now handled dynamically in updateEntityTypeFiltersFromData
    function setupEntityTypeFilters() {
        // Filters are set up dynamically when data loads
    }

    // Relationship filters - now handled dynamically in updateRelationshipTypeFiltersFromData
    function setupRelationshipFilters() {
        // Filters are set up dynamically when data loads
    }

    // Statistics toggle
    window.toggleStatistics = function() {
        const content = document.getElementById(&#39;statisticsContent&#39;);
        const icon = document.getElementById(&#39;statsToggleIcon&#39;);
        
        if (statisticsCollapsed) {
            content.style.display = &#39;block&#39;;
            icon.setAttribute(&#39;data-icon&#39;, &#39;heroicons:chevron-up&#39;);
            statisticsCollapsed = false;
        } else {
            content.style.display = &#39;none&#39;;
            icon.setAttribute(&#39;data-icon&#39;, &#39;heroicons:chevron-down&#39;);
            statisticsCollapsed = true;
        }
    };

    // Graph control functions
    window.searchInGraph = function() {
        const searchTarget = document.getElementById(&#39;searchTargetSelect&#39;)?.value || &#39;node&#39;;
        if (searchTarget === &#39;node&#39;) {
            handleSearch();
        } else {
            handleRelationSearch();
        }
    };
    
    // 更新搜索框placeholder
    window.updateSearchPlaceholder = function() {
        const searchTarget = document.getElementById(&#39;searchTargetSelect&#39;)?.value || &#39;node&#39;;
        const searchInput = document.getElementById(&#39;graphSearchInput&#39;);
        if (searchInput) {
            searchInput.placeholder = searchTarget === &#39;node&#39; ? &#39;搜索节点名称...&#39; : &#39;搜索关系类型...&#39;;
        }
    };
    
    // 关系搜索
    function handleRelationSearch() {
        const query = document.getElementById(&#39;graphSearchInput&#39;).value.toLowerCase().trim();
        const resultsPanel = document.getElementById(&#39;searchResultsPanel&#39;);
        const resultsList = document.getElementById(&#39;searchResultList&#39;);
        const resultCount = document.getElementById(&#39;searchResultCount&#39;);
        
        if (!query) {
            clearSearchHighlight();
            restoreAllElementsOpacity();
            if (resultsPanel) resultsPanel.classList.add(&#39;hidden&#39;);
            return;
        }
        
        const edges = currentGraphData.edges || [];
        const nodes = currentGraphData.nodes || [];
        
        // 搜索匹配的关系
        const matchedEdges = edges.filter(edge =&gt; {
            const edgeType = (edge.type || &#39;关联&#39;).toLowerCase();
            return edgeType.includes(query);
        });
        
        if (matchedEdges.length === 0) {
            if (resultsPanel &amp;&amp; resultsList &amp;&amp; resultCount) {
                resultCount.textContent = 0;
                resultsList.innerHTML = &#39;&lt;div class="text-xs text-base-content/50 text-center py-2"&gt;未找到匹配的关系&lt;/div&gt;&#39;;
                resultsPanel.classList.remove(&#39;hidden&#39;);
            }
            return;
        }
        
        // 收集匹配关系两端的节点ID
        const highlightedNodeIds = new Set();
        matchedEdges.forEach(edge =&gt; {
            highlightedNodeIds.add(edge.sourceNodeId);
            highlightedNodeIds.add(edge.targetNodeId);
        });
        
        // 高亮匹配的边和节点
        document.querySelectorAll(&#39;.graph-node&#39;).forEach(node =&gt; {
            const nodeId = node.getAttribute(&#39;data-node-id&#39;);
            node.style.opacity = highlightedNodeIds.has(nodeId) ? &#39;1&#39; : &#39;0.2&#39;;
        });
        
        document.querySelectorAll(&#39;[data-label-for]&#39;).forEach(label =&gt; {
            const nodeId = label.getAttribute(&#39;data-label-for&#39;);
            label.style.opacity = highlightedNodeIds.has(nodeId) ? &#39;1&#39; : &#39;0.2&#39;;
        });
        
        document.querySelectorAll(&#39;.graph-edge&#39;).forEach(edge =&gt; {
            const source = edge.getAttribute(&#39;data-edge-source&#39;);
            const target = edge.getAttribute(&#39;data-edge-target&#39;);
            const isMatched = matchedEdges.some(e =&gt; 
                (e.sourceNodeId === source &amp;&amp; e.targetNodeId === target) ||
                (e.sourceNodeId === target &amp;&amp; e.targetNodeId === source)
            );
            edge.style.opacity = isMatched ? &#39;0.8&#39; : &#39;0.1&#39;;
            if (isMatched) {
                edge.style.stroke = &#39;#3b82f6&#39;;
                edge.style.strokeWidth = &#39;2.5&#39;;
            }
        });
        
        document.querySelectorAll(&#39;.edge-label&#39;).forEach(label =&gt; {
            const source = label.getAttribute(&#39;data-label-source&#39;);
            const target = label.getAttribute(&#39;data-label-target&#39;);
            const isMatched = matchedEdges.some(e =&gt; 
                (e.sourceNodeId === source &amp;&amp; e.targetNodeId === target) ||
                (e.sourceNodeId === target &amp;&amp; e.targetNodeId === source)
            );
            label.style.opacity = isMatched ? &#39;1&#39; : &#39;0.1&#39;;
        });
        
        // 去重：同一对节点只保留一条关系
        const seenPairs = new Set();
        const uniqueEdges = matchedEdges.filter(edge =&gt; {
            const pairKey1 = `${edge.sourceNodeId}-${edge.targetNodeId}`;
            const pairKey2 = `${edge.targetNodeId}-${edge.sourceNodeId}`;
            if (seenPairs.has(pairKey1) || seenPairs.has(pairKey2)) {
                return false;
            }
            seenPairs.add(pairKey1);
            return true;
        });
        
        // 按关系类型分组显示结果
        const groupedByType = {};
        uniqueEdges.forEach(edge =&gt; {
            const type = edge.type || &#39;关联&#39;;
            if (!groupedByType[type]) groupedByType[type] = [];
            groupedByType[type].push(edge);
        });
        
        // 构建节点名称映射
        const nodeNameMap = {};
        nodes.forEach(n =&gt; nodeNameMap[n.nodeId] = n.name);
        
        // 显示结果
        if (resultsPanel &amp;&amp; resultsList &amp;&amp; resultCount) {
            resultCount.textContent = uniqueEdges.length;
            let html = &#39;&#39;;
            for (const [type, typeEdges] of Object.entries(groupedByType)) {
                html += `&lt;div class="text-xs font-medium text-primary mb-1"&gt;${type} (${typeEdges.length})&lt;/div&gt;`;
                html += typeEdges.slice(0, 5).map(edge =&gt; `
                    &lt;div class="flex items-center gap-1 p-1 hover:bg-base-200 rounded cursor-pointer text-xs" onclick="highlightSingleRelation(&#39;${edge.sourceNodeId}&#39;, &#39;${edge.targetNodeId}&#39;)"&gt;
                        &lt;span class="truncate"&gt;${nodeNameMap[edge.sourceNodeId] || &#39;?&#39;}&lt;/span&gt;
                        &lt;span class="text-base-content/50"&gt;→&lt;/span&gt;
                        &lt;span class="truncate"&gt;${nodeNameMap[edge.targetNodeId] || &#39;?&#39;}&lt;/span&gt;
                    &lt;/div&gt;
                `).join(&#39;&#39;);
                if (typeEdges.length &gt; 5) {
                    html += `&lt;div class="text-xs text-base-content/50 pl-2"&gt;...还有 ${typeEdges.length - 5} 条&lt;/div&gt;`;
                }
            }
            resultsList.innerHTML = html;
            resultsPanel.classList.remove(&#39;hidden&#39;);
        }
        
        window.showNotification(`找到 ${uniqueEdges.length} 条匹配的关系`, &#39;info&#39;);
    }
    
    // 高亮单条关系
    window.highlightSingleRelation = function(sourceId, targetId) {
        // 先恢复所有元素透明度
        restoreAllElementsOpacity();
        
        // 降低所有透明度
        document.querySelectorAll(&#39;.graph-node&#39;).forEach(n =&gt; n.style.opacity = &#39;0.2&#39;);
        document.querySelectorAll(&#39;[data-label-for]&#39;).forEach(l =&gt; l.style.opacity = &#39;0.2&#39;);
        document.querySelectorAll(&#39;.graph-edge&#39;).forEach(e =&gt; e.style.opacity = &#39;0.1&#39;);
        document.querySelectorAll(&#39;.edge-label&#39;).forEach(l =&gt; l.style.opacity = &#39;0.1&#39;);
        
        // 高亮选中的关系两端节点
        [sourceId, targetId].forEach(nodeId =&gt; {
            const node = document.querySelector(`[data-node-id="${nodeId}"]`);
            if (node) node.style.opacity = &#39;1&#39;;
            const label = document.querySelector(`[data-label-for="${nodeId}"]`);
            if (label) label.style.opacity = &#39;1&#39;;
        });
        
        // 高亮选中的边
        document.querySelectorAll(&#39;.graph-edge&#39;).forEach(edge =&gt; {
            const source = edge.getAttribute(&#39;data-edge-source&#39;);
            const target = edge.getAttribute(&#39;data-edge-target&#39;);
            if ((source === sourceId &amp;&amp; target === targetId) || (source === targetId &amp;&amp; target === sourceId)) {
                edge.style.opacity = &#39;1&#39;;
                edge.style.stroke = &#39;#3b82f6&#39;;
                edge.style.strokeWidth = &#39;3&#39;;
            }
        });
        
        // 高亮边标签
        document.querySelectorAll(&#39;.edge-label&#39;).forEach(label =&gt; {
            const source = label.getAttribute(&#39;data-label-source&#39;);
            const target = label.getAttribute(&#39;data-label-target&#39;);
            if ((source === sourceId &amp;&amp; target === targetId) || (source === targetId &amp;&amp; target === sourceId)) {
                label.style.opacity = &#39;1&#39;;
            }
        });
    };

    window.zoomIn = function() {
        graphZoom = Math.min(graphZoom * 1.2, 3);
        applyGraphTransform();
    };

    window.zoomOut = function() {
        graphZoom = Math.max(graphZoom / 1.2, 0.3);
        applyGraphTransform();
    };

    window.resetView = function() {
        graphZoom = 1;
        graphPan = { x: 0, y: 0 };
        applyGraphTransform();
    };

    function applyGraphTransform() {
        const svg = document.querySelector(&#39;#graphCanvas svg&#39;);
        if (svg) {
            svg.style.transform = `scale(${graphZoom}) translate(${graphPan.x}px, ${graphPan.y}px)`;
        }
    }

    // Action functions
    window.toggleFavorite = function() {
        const isFavorited = window.APP_GLOBALS.favorites.isFavorited(currentGraphData.id);
        
        if (isFavorited) {
            window.APP_GLOBALS.favorites.remove(currentGraphData.id);
        } else {
            window.APP_GLOBALS.favorites.add(currentGraphData.id, currentGraphData);
            navigateTo(&#39;user_profile_page&#39;);
        }
        
        updateFavoriteButton();
    };

    function updateFavoriteButton() {
        const btn = document.getElementById(&#39;favoriteBtn&#39;);
        const icon = btn.querySelector(&#39;.iconify&#39;);
        const isFavorited = window.APP_GLOBALS.favorites.isFavorited(currentGraphData.id);
        
        if (isFavorited) {
            icon.setAttribute(&#39;data-icon&#39;, &#39;heroicons:heart-solid&#39;);
            icon.classList.add(&#39;favorite-active&#39;);
        } else {
            icon.setAttribute(&#39;data-icon&#39;, &#39;heroicons:heart&#39;);
            icon.classList.remove(&#39;favorite-active&#39;);
        }
    }

    window.shareGraph = function() {
        // Generate share link - use the stored shareLink if available
        let shareUrl;
        if (currentGraphData.shareLink) {
            shareUrl = `${window.location.origin}/graph/graph_detail.html?share=${currentGraphData.shareLink}`;
        } else if (currentGraphData.id) {
            shareUrl = `${window.location.origin}/graph/graph_detail.html?id=${currentGraphData.id}`;
        } else {
            shareUrl = window.location.href;
        }
        document.getElementById(&#39;shareLink&#39;).value = shareUrl;
        
        // Show modal
        document.getElementById(&#39;shareModal&#39;).showModal();
    };

    window.downloadGraph = function() {
        // Generate initial download link
        const downloadUrl = `${window.location.origin}/api/download/${currentGraphData.id}`;
        document.getElementById(&#39;downloadLink&#39;).value = downloadUrl;
        
        // Show modal
        document.getElementById(&#39;downloadModal&#39;).showModal();
    };

    // Copy share link function
    window.copyShareLink = function() {
        const shareLink = document.getElementById(&#39;shareLink&#39;);
        shareLink.select();
        shareLink.setSelectionRange(0, 99999);
        
        navigator.clipboard.writeText(shareLink.value).then(() => {
            const btn = document.getElementById(&#39;copyShareBtn&#39;);
            const originalText = btn.innerHTML;
            
            btn.innerHTML = &#39;<span class="iconify" data-icon="heroicons:check" data-width="16"></span>已复制&#39;;
            btn.classList.add(&#39;btn-success&#39;);
            btn.classList.remove(&#39;btn-primary&#39;);
            
            setTimeout(() => {
                btn.innerHTML = originalText;
                btn.classList.remove(&#39;btn-success&#39;);
                btn.classList.add(&#39;btn-primary&#39;);
            }, 2000);
            
            window.showNotification(&#39;分享链接已复制到剪贴板&#39;, &#39;success&#39;);
        }).catch(() => {
            window.showNotification(&#39;复制失败，请手动复制&#39;, &#39;error&#39;);
        });
    };

    // Copy download link function
    window.copyDownloadLink = function() {
        const downloadLink = document.getElementById(&#39;downloadLink&#39;);
        downloadLink.select();
        downloadLink.setSelectionRange(0, 99999);
        
        navigator.clipboard.writeText(downloadLink.value).then(() => {
            const btn = document.getElementById(&#39;copyDownloadBtn&#39;);
            const originalText = btn.innerHTML;
            
            btn.innerHTML = &#39;<span class="iconify" data-icon="heroicons:check" data-width="16"></span>已复制&#39;;
            btn.classList.add(&#39;btn-success&#39;);
            btn.classList.remove(&#39;btn-primary&#39;);
            
            setTimeout(() => {
                btn.innerHTML = originalText;
                btn.classList.remove(&#39;btn-success&#39;);
                btn.classList.add(&#39;btn-primary&#39;);
            }, 2000);
            
            window.showNotification(&#39;下载链接已复制到剪贴板&#39;, &#39;success&#39;);
        }).catch(() => {
            window.showNotification(&#39;复制失败，请手动复制&#39;, &#39;error&#39;);
        });
    };

    // Download format selection
    window.downloadFormat = function(format) {
        const baseUrl = `${window.location.origin}/api/download/${currentGraphData.id}`;
        let downloadUrl = &#39;&#39;;
        
        switch(format) {
            case &#39;json&#39;:
                downloadUrl = `${baseUrl}?format=json`;
                break;
            case &#39;csv&#39;:
                downloadUrl = `${baseUrl}?format=csv`;
                break;
            case &#39;png&#39;:
                downloadUrl = `${baseUrl}?format=png`;
                break;
            default:
                downloadUrl = baseUrl;
        }
        
        document.getElementById(&#39;downloadLink&#39;).value = downloadUrl;
        window.showNotification(`已生成${format.toUpperCase()}格式下载链接`, &#39;info&#39;);
    };

    window.toggleFullscreen = function() {
        const graphContainer = document.querySelector(&#39;.flex-1.flex&#39;);
        
        if (!isFullscreen) {
            if (graphContainer.requestFullscreen) {
                graphContainer.requestFullscreen();
            }
            isFullscreen = true;
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            }
            isFullscreen = false;
        }
    };

    // Handle fullscreen change
    document.addEventListener(&#39;fullscreenchange&#39;, function() {
        isFullscreen = !!document.fullscreenElement;
    });

    // ==================== 节点管理功能 ====================
    
    // 当前导入模式
    let currentImportMode = &#39;single&#39;;
    
    // 检查编辑权限并显示编辑区域
    async function checkAndShowEditSection() {
        const graphId = currentGraphData.id;
        if (!graphId) return;
        
        try {
            // 检查用户是否有编辑权限（图谱创建者或管理员）
            const response = await fetch(`/api/graph/${graphId}/can-edit`, {
                credentials: &#39;include&#39;
            });
            
            if (response.ok) {
                const result = await response.json();
                if (result.canEdit) {
                    document.getElementById(&#39;nodeManagementSection&#39;).style.display = &#39;block&#39;;
                }
            }
        } catch (error) {
            // 权限检查失败，默认不显示编辑区域
            console.log(&#39;权限检查失败:&#39;, error);
        }
    }
    
    // 切换导入标签页
    window.switchImportTab = function(mode) {
        currentImportMode = mode;
        
        const singleTab = document.getElementById(&#39;singleImportTab&#39;);
        const batchTab = document.getElementById(&#39;batchImportTab&#39;);
        const singleForm = document.getElementById(&#39;singleImportForm&#39;);
        const batchForm = document.getElementById(&#39;batchImportForm&#39;);
        
        if (mode === &#39;single&#39;) {
            singleTab.classList.add(&#39;tab-active&#39;);
            batchTab.classList.remove(&#39;tab-active&#39;);
            singleForm.classList.remove(&#39;hidden&#39;);
            batchForm.classList.add(&#39;hidden&#39;);
        } else {
            singleTab.classList.remove(&#39;tab-active&#39;);
            batchTab.classList.add(&#39;tab-active&#39;);
            singleForm.classList.add(&#39;hidden&#39;);
            batchForm.classList.remove(&#39;hidden&#39;);
        }
    };
    
    // 打开导入节点模态框
    window.openBatchImportModal = function() {
        document.getElementById(&#39;singleNodeName&#39;).value = &#39;&#39;;
        document.getElementById(&#39;singleNodeType&#39;).value = &#39;&#39;;
        document.getElementById(&#39;singleNodeDescription&#39;).value = &#39;&#39;;
        document.getElementById(&#39;singleNodeImportance&#39;).value = &#39;5&#39;;
        document.getElementById(&#39;batchImportInput&#39;).value = &#39;&#39;;
        switchImportTab(&#39;single&#39;);
        document.getElementById(&#39;batchImportModal&#39;).showModal();
    };
    
    // 执行导入节点（支持单个和批量）
    window.executeImportNodes = async function() {
        const graphId = currentGraphData.id;
        if (!graphId) {
            window.showNotification(&#39;请先选择图谱&#39;, &#39;error&#39;);
            return;
        }
        
        let nodes = [];
        
        if (currentImportMode === &#39;single&#39;) {
            const name = document.getElementById(&#39;singleNodeName&#39;).value.trim();
            const type = document.getElementById(&#39;singleNodeType&#39;).value.trim() || &#39;默认&#39;;
            const description = document.getElementById(&#39;singleNodeDescription&#39;).value.trim();
            const importance = parseInt(document.getElementById(&#39;singleNodeImportance&#39;).value) || 5;
            
            if (!name) {
                window.showNotification(&#39;请输入节点名称&#39;, &#39;warning&#39;);
                return;
            }
            
            nodes = [{ name, type, description, importance }];
        } else {
            const input = document.getElementById(&#39;batchImportInput&#39;).value.trim();
            if (!input) {
                window.showNotification(&#39;请输入要导入的节点&#39;, &#39;warning&#39;);
                return;
            }
            
            const lines = input.split(&#39;\n&#39;).filter(line =&gt; line.trim());
            nodes = lines.map(line =&gt; {
                const parts = line.split(&#39;,&#39;).map(p =&gt; p.trim());
                return {
                    name: parts[0] || &#39;&#39;,
                    type: parts[1] || &#39;默认&#39;,
                    description: parts[2] || &#39;&#39;,
                    importance: parseInt(parts[3]) || 5
                };
            }).filter(n =&gt; n.name);
        }
        
        if (nodes.length === 0) {
            window.showNotification(&#39;未找到有效的节点数据&#39;, &#39;warning&#39;);
            return;
        }
        
        try {
            const endpoint = nodes.length === 1 ? `/api/graph/${graphId}/nodes` : `/api/graph/${graphId}/nodes/batch`;
            const body = nodes.length === 1 ? nodes[0] : nodes;
            
            const response = await fetch(endpoint, {
                method: &#39;POST&#39;,
                headers: { &#39;Content-Type&#39;: &#39;application/json&#39; },
                credentials: &#39;include&#39;,
                body: JSON.stringify(body)
            });
            
            const result = await response.json();
            if (response.ok &amp;&amp; result.success) {
                const msg = nodes.length === 1 ? &#39;节点创建成功&#39; : `成功导入 ${result.count} 个节点`;
                window.showNotification(msg, &#39;success&#39;);
                document.getElementById(&#39;batchImportModal&#39;).close();
                const data = await loadGraphData(graphId);
                if (data) {
                    updatePageWithGraphData(data);
                    renderGraphFromData();
                }
            } else {
                window.showNotification(result.error || &#39;操作失败&#39;, &#39;error&#39;);
            }
        } catch (error) {
            window.showNotification(&#39;请求失败: &#39; + error.message, &#39;error&#39;);
        }
    };
    
    // 打开删除节点模态框
    window.openBatchDeleteModal = function() {
        populateDeleteModal();
        document.getElementById(&#39;batchDeleteModal&#39;).showModal();
    };
    
    // 填充删除模态框数据
    function populateDeleteModal() {
        const nodes = currentGraphData.nodes || [];
        const types = [...new Set(nodes.map(n =&gt; n.type || &#39;未分类&#39;))];
        
        const typeSelect = document.getElementById(&#39;deleteTypeFilter&#39;);
        typeSelect.innerHTML = &#39;<option value="">全部类型</option>&#39; + 
            types.map(t =&gt; `<option value="${t}">${t}</option>`).join(&#39;&#39;);
        
        document.getElementById(&#39;deleteSearchInput&#39;).value = &#39;&#39;;
        renderDeleteNodeList(nodes);
        updateSelectedDeleteCount();
    }
    
    // 渲染删除节点列表
    function renderDeleteNodeList(nodes) {
        const container = document.getElementById(&#39;deleteNodeList&#39;);
        if (nodes.length === 0) {
            container.innerHTML = &#39;<div class="text-sm text-base-content/50 text-center">暂无节点</div>&#39;;
            return;
        }
        
        container.innerHTML = nodes.map(node =&gt; `
            <label class="flex items-center gap-2 p-2 hover:bg-base-200 rounded cursor-pointer">
                <input type="checkbox" class="checkbox checkbox-sm delete-node-checkbox" data-node-id="${node.nodeId}">
                <span class="flex-1">${node.name || &#39;未命名&#39;}</span>
                <span class="badge badge-ghost badge-xs">${node.type || &#39;未分类&#39;}</span>
            </label>
        `).join(&#39;&#39;);
        
        container.querySelectorAll(&#39;.delete-node-checkbox&#39;).forEach(cb =&gt; {
            cb.addEventListener(&#39;change&#39;, updateSelectedDeleteCount);
        });
    }
    
    window.filterDeleteNodes = function() {
        const typeFilter = document.getElementById(&#39;deleteTypeFilter&#39;).value;
        const searchKeyword = document.getElementById(&#39;deleteSearchInput&#39;).value.toLowerCase().trim();
        
        let filtered = currentGraphData.nodes || [];
        if (typeFilter) {
            filtered = filtered.filter(n =&gt; (n.type || &#39;未分类&#39;) === typeFilter);
        }
        if (searchKeyword) {
            filtered = filtered.filter(n =&gt; (n.name || &#39;&#39;).toLowerCase().includes(searchKeyword));
        }
        
        renderDeleteNodeList(filtered);
    };
    
    window.selectAllDeleteNodes = function() {
        document.querySelectorAll(&#39;.delete-node-checkbox&#39;).forEach(cb =&gt; cb.checked = true);
        updateSelectedDeleteCount();
    };
    
    window.deselectAllDeleteNodes = function() {
        document.querySelectorAll(&#39;.delete-node-checkbox&#39;).forEach(cb =&gt; cb.checked = false);
        updateSelectedDeleteCount();
    };
    
    function updateSelectedDeleteCount() {
        const count = document.querySelectorAll(&#39;.delete-node-checkbox:checked&#39;).length;
        document.getElementById(&#39;selectedDeleteCount&#39;).textContent = `已选择 ${count} 个节点`;
    }
    
    window.executeBatchDelete = async function() {
        const graphId = currentGraphData.id;
        if (!graphId) {
            window.showNotification(&#39;请先选择图谱&#39;, &#39;error&#39;);
            return;
        }
        
        const selectedNodes = [];
        document.querySelectorAll(&#39;.delete-node-checkbox:checked&#39;).forEach(cb =&gt; {
            selectedNodes.push(cb.getAttribute(&#39;data-node-id&#39;));
        });
        
        if (selectedNodes.length === 0) {
            window.showNotification(&#39;请选择要删除的节点&#39;, &#39;warning&#39;);
            return;
        }
        
        if (!confirm(`确定要删除选中的 ${selectedNodes.length} 个节点吗？此操作不可恢复！`)) {
            return;
        }
        
        try {
            const response = await fetch(`/api/graph/${graphId}/nodes/batch`, {
                method: &#39;DELETE&#39;,
                headers: { &#39;Content-Type&#39;: &#39;application/json&#39; },
                credentials: &#39;include&#39;,
                body: JSON.stringify(selectedNodes)
            });
            
            const result = await response.json();
            if (response.ok &amp;&amp; result.success) {
                window.showNotification(result.message || &#39;删除成功&#39;, &#39;success&#39;);
                document.getElementById(&#39;batchDeleteModal&#39;).close();
                const data = await loadGraphData(graphId);
                if (data) {
                    updatePageWithGraphData(data);
                    renderGraphFromData();
                }
            } else {
                window.showNotification(result.error || &#39;删除失败&#39;, &#39;error&#39;);
            }
        } catch (error) {
            window.showNotification(&#39;删除请求失败: &#39; + error.message, &#39;error&#39;);
        }
    };
    
    // ==================== 关系管理功能 ====================
    
    // 打开删除关系模态框
    window.openDeleteRelationModal = function() {
        populateDeleteRelationModal();
        document.getElementById(&#39;deleteRelationModal&#39;).showModal();
    };
    
    // 填充删除关系模态框数据
    function populateDeleteRelationModal() {
        const edges = currentGraphData.edges || [];
        const types = [...new Set(edges.map(e =&gt; e.type || &#39;关联&#39;))];
        
        const typeSelect = document.getElementById(&#39;deleteRelationTypeFilter&#39;);
        typeSelect.innerHTML = &#39;<option value="">全部类型</option>&#39; + 
            types.map(t =&gt; `<option value="${t}">${t}</option>`).join(&#39;&#39;);
        
        document.getElementById(&#39;deleteRelationSearchInput&#39;).value = &#39;&#39;;
        renderDeleteRelationList(edges);
        updateSelectedDeleteRelationCount();
    }
    
    // 渲染删除关系列表
    function renderDeleteRelationList(edges) {
        const container = document.getElementById(&#39;deleteRelationList&#39;);
        if (edges.length === 0) {
            container.innerHTML = &#39;<div class="text-sm text-base-content/50 text-center">暂无关系</div>&#39;;
            return;
        }
        
        container.innerHTML = edges.map(edge =&gt; `
            <label class="flex items-center gap-2 p-2 hover:bg-base-200 rounded cursor-pointer">
                <input type="checkbox" class="checkbox checkbox-sm delete-relation-checkbox" data-relation-id="${edge.relationId}">
                <span class="flex-1 text-sm">${edge.sourceNodeName || &#39;?&#39;} → ${edge.targetNodeName || &#39;?&#39;}</span>
                <span class="badge badge-secondary badge-xs">${edge.type || &#39;关联&#39;}</span>
            </label>
        `).join(&#39;&#39;);
        
        container.querySelectorAll(&#39;.delete-relation-checkbox&#39;).forEach(cb =&gt; {
            cb.addEventListener(&#39;change&#39;, updateSelectedDeleteRelationCount);
        });
    }
    
    window.filterDeleteRelations = function() {
        const typeFilter = document.getElementById(&#39;deleteRelationTypeFilter&#39;).value;
        const searchKeyword = document.getElementById(&#39;deleteRelationSearchInput&#39;).value.toLowerCase().trim();
        
        let filtered = currentGraphData.edges || [];
        if (typeFilter) {
            filtered = filtered.filter(e =&gt; (e.type || &#39;关联&#39;) === typeFilter);
        }
        if (searchKeyword) {
            filtered = filtered.filter(e =&gt; 
                (e.sourceNodeName || &#39;&#39;).toLowerCase().includes(searchKeyword) ||
                (e.targetNodeName || &#39;&#39;).toLowerCase().includes(searchKeyword)
            );
        }
        
        renderDeleteRelationList(filtered);
    };
    
    window.selectAllDeleteRelations = function() {
        document.querySelectorAll(&#39;.delete-relation-checkbox&#39;).forEach(cb =&gt; cb.checked = true);
        updateSelectedDeleteRelationCount();
    };
    
    window.deselectAllDeleteRelations = function() {
        document.querySelectorAll(&#39;.delete-relation-checkbox&#39;).forEach(cb =&gt; cb.checked = false);
        updateSelectedDeleteRelationCount();
    };
    
    function updateSelectedDeleteRelationCount() {
        const count = document.querySelectorAll(&#39;.delete-relation-checkbox:checked&#39;).length;
        document.getElementById(&#39;selectedDeleteRelationCount&#39;).textContent = `已选择 ${count} 个关系`;
    }
    
    window.executeBatchDeleteRelations = async function() {
        const graphId = currentGraphData.id;
        if (!graphId) {
            window.showNotification(&#39;请先选择图谱&#39;, &#39;error&#39;);
            return;
        }
        
        const selectedRelations = [];
        document.querySelectorAll(&#39;.delete-relation-checkbox:checked&#39;).forEach(cb =&gt; {
            selectedRelations.push(cb.getAttribute(&#39;data-relation-id&#39;));
        });
        
        if (selectedRelations.length === 0) {
            window.showNotification(&#39;请选择要删除的关系&#39;, &#39;warning&#39;);
            return;
        }
        
        if (!confirm(`确定要删除选中的 ${selectedRelations.length} 个关系吗？此操作不可恢复！`)) {
            return;
        }
        
        try {
            const response = await fetch(`/api/graph/${graphId}/relations/batch`, {
                method: &#39;DELETE&#39;,
                headers: { &#39;Content-Type&#39;: &#39;application/json&#39; },
                credentials: &#39;include&#39;,
                body: JSON.stringify(selectedRelations)
            });
            
            const result = await response.json();
            if (response.ok &amp;&amp; result.success) {
                window.showNotification(result.message || &#39;删除成功&#39;, &#39;success&#39;);
                document.getElementById(&#39;deleteRelationModal&#39;).close();
                const data = await loadGraphData(graphId);
                if (data) {
                    updatePageWithGraphData(data);
                    renderGraphFromData();
                }
            } else {
                window.showNotification(result.error || &#39;删除失败&#39;, &#39;error&#39;);
            }
        } catch (error) {
            window.showNotification(&#39;删除请求失败: &#39; + error.message, &#39;error&#39;);
        }
    };
    
    // ==================== 搜索增强功能 ====================
    
    // 筛选与排序处理
    window.handleFilterSort = function(value) {
        if (!value) {
            // 全部类型 - 显示所有节点
            handleSearch();
            return;
        }
        
        if (value === &#39;sort_degree&#39;) {
            // 按度数排序
            showNodesByDegree();
            document.getElementById(&#39;searchTypeFilter&#39;).value = &#39;&#39;;
        } else if (value.startsWith(&#39;type_&#39;)) {
            // 按类型筛选
            const type = value.substring(5);
            filterByType(type);
        }
    };
    
    // 按类型筛选节点
    function filterByType(type) {
        const nodes = currentGraphData.nodes || [];
        const filteredNodes = nodes.filter(n =&gt; (n.type || &#39;未分类&#39;) === type);
        
        const resultsPanel = document.getElementById(&#39;searchResultsPanel&#39;);
        const resultsList = document.getElementById(&#39;searchResultList&#39;);
        const resultCount = document.getElementById(&#39;searchResultCount&#39;);
        
        if (resultsPanel &amp;&amp; resultsList &amp;&amp; resultCount) {
            resultCount.textContent = filteredNodes.length;
            resultsList.innerHTML = filteredNodes.map(node =&gt; `
                &lt;div class="flex items-center gap-2 p-2 hover:bg-base-200 rounded cursor-pointer text-xs" onclick="highlightAndSelectNode(&#39;${node.nodeId}&#39;)"&gt;
                    &lt;span class="flex-1 truncate"&gt;${node.name || &#39;未命名&#39;}&lt;/span&gt;
                    &lt;span class="badge badge-ghost badge-xs"&gt;${node.type || &#39;未分类&#39;}&lt;/span&gt;
                &lt;/div&gt;
            `).join(&#39;&#39;);
            resultsPanel.classList.remove(&#39;hidden&#39;);
        }
        
        window.showNotification(`找到 ${filteredNodes.length} 个 "${type}" 类型节点`, &#39;info&#39;);
    }
    
    // 按类型筛选搜索（兼容旧代码）
    window.filterSearchByType = function() {
        handleSearch();
    };
    
    // 高亮并选中节点
    window.highlightAndSelectNode = function(nodeId) {
        // 调用showCenteredGraphView更新图谱布局并选中节点
        showCenteredGraphView(nodeId);
    };
    
    // 打开邻居查询模态框
    window.openNeighborQueryModal = function() {
        const nodes = currentGraphData.nodes || [];
        // 按字典序排序
        const sortedNodes = [...nodes].sort(function(a, b) {
            const nameA = (a.name || &#39;&#39;).toLowerCase();
            const nameB = (b.name || &#39;&#39;).toLowerCase();
            return nameA.localeCompare(nameB, &#39;zh-CN&#39;);
        });
        
        // 使用 datalist 实现可输入搜索
        const datalistOptions = sortedNodes.map(function(n) {
            return &#39;&lt;option value="&#39; + (n.name || &#39;未命名&#39;) + &#39;"&gt;&#39;;
        }).join(&#39;&#39;);
        document.getElementById(&#39;neighborTargetNodeList&#39;).innerHTML = datalistOptions;
        document.getElementById(&#39;neighborTargetNodeInput&#39;).value = &#39;&#39;;
        
        // 保存节点映射供查询使用
        window._neighborQueryNodes = sortedNodes;
        
        document.getElementById(&#39;neighborResults&#39;).classList.add(&#39;hidden&#39;);
        document.getElementById(&#39;neighborQueryModal&#39;).showModal();
    };
    
    window.executeNeighborQuery = async function() {
        const graphId = currentGraphData.id;
        const nodeName = document.getElementById(&#39;neighborTargetNodeInput&#39;).value.trim();
        const direction = document.getElementById(&#39;neighborDirection&#39;).value;
        
        if (!nodeName) {
            window.showNotification(&#39;请输入目标节点&#39;, &#39;warning&#39;);
            return;
        }
        
        // 通过名称查找节点ID
        const nodes = window._neighborQueryNodes || currentGraphData.nodes || [];
        const targetNode = nodes.find(function(n) { return n.name === nodeName; });
        if (!targetNode) {
            window.showNotification(&#39;未找到节点: &#39; + nodeName, &#39;warning&#39;);
            return;
        }
        const nodeId = targetNode.nodeId;
        
        try {
            const response = await fetch(`/api/graph/${graphId}/nodes/${nodeId}/neighbors?direction=${direction}`, {
                credentials: &#39;include&#39;
            });
            
            if (!response.ok) {
                throw new Error(&#39;查询失败&#39;);
            }
            
            const neighbors = await response.json();
            
            const resultsContainer = document.getElementById(&#39;neighborResults&#39;);
            const resultList = document.getElementById(&#39;neighborResultList&#39;);
            
            if (neighbors.length === 0) {
                resultList.innerHTML = &#39;<div class="text-sm text-base-content/50 text-center">该节点没有邻居</div>&#39;;
            } else {
                resultList.innerHTML = neighbors.map(node =&gt; `
                    <div class="flex items-center gap-2 p-2 hover:bg-base-200 rounded cursor-pointer" onclick="highlightAndSelectNode(&#39;${node.nodeId}&#39;); document.getElementById(&#39;neighborQueryModal&#39;).close();">
                        <span class="flex-1">${node.name || &#39;未命名&#39;}</span>
                        <span class="badge badge-ghost badge-xs">${node.type || &#39;未分类&#39;}</span>
                    </div>
                `).join(&#39;&#39;);
            }
            
            resultsContainer.classList.remove(&#39;hidden&#39;);
            window.showNotification(`找到 ${neighbors.length} 个邻居节点`, &#39;success&#39;);
            
        } catch (error) {
            window.showNotification(&#39;邻居查询失败: &#39; + error.message, &#39;error&#39;);
        }
    };
    
    // 打开添加关系模态框
    window.openAddRelationModal = function() {
        const nodes = currentGraphData.nodes || [];
        // 按字典序排序
        const sortedNodes = [...nodes].sort(function(a, b) {
            const nameA = (a.name || &#39;&#39;).toLowerCase();
            const nameB = (b.name || &#39;&#39;).toLowerCase();
            return nameA.localeCompare(nameB, &#39;zh-CN&#39;);
        });
        
        // 使用 datalist 实现可输入搜索
        const datalistOptions = sortedNodes.map(function(n) {
            return &#39;&lt;option value="&#39; + (n.name || &#39;未命名&#39;) + &#39;"&gt;&#39;;
        }).join(&#39;&#39;);
        
        document.getElementById(&#39;newRelationSourceList&#39;).innerHTML = datalistOptions;
        document.getElementById(&#39;newRelationTargetList&#39;).innerHTML = datalistOptions;
        document.getElementById(&#39;newRelationSourceInput&#39;).value = &#39;&#39;;
        document.getElementById(&#39;newRelationTargetInput&#39;).value = &#39;&#39;;
        document.getElementById(&#39;newRelationType&#39;).value = &#39;关联&#39;;
        
        // 保存节点映射供查询使用
        window._addRelationNodes = sortedNodes;
        
        document.getElementById(&#39;addRelationModal&#39;).showModal();
    };
    
    window.executeAddRelation = async function() {
        const graphId = currentGraphData.id;
        if (!graphId) {
            window.showNotification(&#39;请先选择图谱&#39;, &#39;error&#39;);
            return;
        }
        
        const sourceName = document.getElementById(&#39;newRelationSourceInput&#39;).value.trim();
        const targetName = document.getElementById(&#39;newRelationTargetInput&#39;).value.trim();
        const type = document.getElementById(&#39;newRelationType&#39;).value.trim() || &#39;关联&#39;;
        
        if (!sourceName || !targetName) {
            window.showNotification(&#39;请输入源节点和目标节点&#39;, &#39;warning&#39;);
            return;
        }
        
        // 通过名称查找节点ID
        const nodes = window._addRelationNodes || currentGraphData.nodes || [];
        const sourceNode = nodes.find(function(n) { return n.name === sourceName; });
        const targetNode = nodes.find(function(n) { return n.name === targetName; });
        
        if (!sourceNode) {
            window.showNotification(&#39;未找到源节点: &#39; + sourceName, &#39;warning&#39;);
            return;
        }
        if (!targetNode) {
            window.showNotification(&#39;未找到目标节点: &#39; + targetName, &#39;warning&#39;);
            return;
        }
        
        const sourceNodeId = sourceNode.nodeId;
        const targetNodeId = targetNode.nodeId;
        
        if (sourceNodeId === targetNodeId) {
            window.showNotification(&#39;源节点和目标节点不能相同&#39;, &#39;warning&#39;);
            return;
        }
        
        try {
            const response = await fetch(`/api/graph/${graphId}/relations`, {
                method: &#39;POST&#39;,
                headers: { &#39;Content-Type&#39;: &#39;application/json&#39; },
                credentials: &#39;include&#39;,
                body: JSON.stringify({ sourceNodeId, targetNodeId, type })
            });
            
            const result = await response.json();
            if (response.ok &amp;&amp; result.success) {
                window.showNotification(&#39;关系创建成功&#39;, &#39;success&#39;);
                document.getElementById(&#39;addRelationModal&#39;).close();
                const data = await loadGraphData(graphId);
                if (data) {
                    updatePageWithGraphData(data);
                    renderGraphFromData();
                }
            } else {
                window.showNotification(result.error || &#39;创建失败&#39;, &#39;error&#39;);
            }
        } catch (error) {
            window.showNotification(&#39;创建请求失败: &#39; + error.message, &#39;error&#39;);
        }
    };
    
    // ==================== 批量关系操作功能 ====================
    
    // 切换添加关系Tab
    window.switchRelationTab = function(mode) {
        const singleTab = document.getElementById(&#39;singleRelationTab&#39;);
        const batchTab = document.getElementById(&#39;batchRelationTab&#39;);
        const singleForm = document.getElementById(&#39;singleRelationForm&#39;);
        const batchForm = document.getElementById(&#39;batchRelationForm&#39;);
        
        if (mode === &#39;single&#39;) {
            singleTab.classList.add(&#39;tab-active&#39;);
            batchTab.classList.remove(&#39;tab-active&#39;);
            singleForm.classList.remove(&#39;hidden&#39;);
            batchForm.classList.add(&#39;hidden&#39;);
        } else {
            singleTab.classList.remove(&#39;tab-active&#39;);
            batchTab.classList.add(&#39;tab-active&#39;);
            singleForm.classList.add(&#39;hidden&#39;);
            batchForm.classList.remove(&#39;hidden&#39;);
        }
    };
    
    // 预览批量关系
    window.previewBatchRelations = function() {
        const input = document.getElementById(&#39;batchRelationInput&#39;).value.trim();
        const previewContainer = document.getElementById(&#39;batchRelationPreview&#39;);
        const previewList = document.getElementById(&#39;batchRelationPreviewList&#39;);
        const nodes = currentGraphData.nodes || [];
        
        if (!input) {
            previewContainer.classList.add(&#39;hidden&#39;);
            return;
        }
        
        const lines = input.split(&#39;\n&#39;).filter(l =&gt; l.trim());
        const relations = [];
        const errors = [];
        
        lines.forEach((line, idx) =&gt; {
            const parts = line.split(&#39;,&#39;).map(p =&gt; p.trim());
            if (parts.length &lt; 2) {
                errors.push(`第${idx + 1}行格式错误`);
                return;
            }
            
            const sourceName = parts[0];
            const targetName = parts[1];
            const type = parts[2] || &#39;关联&#39;;
            
            const sourceNode = nodes.find(n =&gt; n.name === sourceName);
            const targetNode = nodes.find(n =&gt; n.name === targetName);
            
            if (!sourceNode) {
                errors.push(`第${idx + 1}行：找不到源节点"${sourceName}"`);
            } else if (!targetNode) {
                errors.push(`第${idx + 1}行：找不到目标节点"${targetName}"`);
            } else {
                relations.push({ sourceNode, targetNode, type, sourceName, targetName });
            }
        });
        
        let html = &#39;&#39;;
        relations.forEach(r =&gt; {
            html += `<div class="flex items-center gap-2 text-sm p-1 bg-base-100 rounded">
                <span class="badge badge-sm badge-primary">${r.sourceName}</span>
                <span class="text-base-content/50">→</span>
                <span class="badge badge-sm badge-ghost">${r.type}</span>
                <span class="text-base-content/50">→</span>
                <span class="badge badge-sm badge-secondary">${r.targetName}</span>
            </div>`;
        });
        
        if (errors.length &gt; 0) {
            html += `<div class="mt-2 text-error text-xs">${errors.join(&#39;<br>&#39;)}</div>`;
        }
        
        html += `<div class="mt-2 text-xs text-base-content/60">共 ${relations.length} 条有效关系</div>`;
        
        previewList.innerHTML = html;
        previewContainer.classList.remove(&#39;hidden&#39;);
    };
    
    // 执行批量添加关系
    window.executeBatchAddRelations = async function() {
        const graphId = currentGraphData.id;
        if (!graphId) {
            window.showNotification(&#39;请先选择图谱&#39;, &#39;error&#39;);
            return;
        }
        
        const input = document.getElementById(&#39;batchRelationInput&#39;).value.trim();
        if (!input) {
            window.showNotification(&#39;请输入关系数据&#39;, &#39;warning&#39;);
            return;
        }
        
        const nodes = currentGraphData.nodes || [];
        const lines = input.split(&#39;\n&#39;).filter(l =&gt; l.trim());
        const relations = [];
        
        lines.forEach(line =&gt; {
            const parts = line.split(&#39;,&#39;).map(p =&gt; p.trim());
            if (parts.length &lt; 2) return;
            
            const sourceNode = nodes.find(n =&gt; n.name === parts[0]);
            const targetNode = nodes.find(n =&gt; n.name === parts[1]);
            
            if (sourceNode &amp;&amp; targetNode) {
                relations.push({
                    sourceNodeId: sourceNode.nodeId,
                    targetNodeId: targetNode.nodeId,
                    type: parts[2] || &#39;关联&#39;
                });
            }
        });
        
        if (relations.length === 0) {
            window.showNotification(&#39;没有有效的关系数据&#39;, &#39;warning&#39;);
            return;
        }
        
        let successCount = 0;
        let failCount = 0;
        
        for (const rel of relations) {
            try {
                const response = await fetch(`/api/graph/${graphId}/relations`, {
                    method: &#39;POST&#39;,
                    headers: { &#39;Content-Type&#39;: &#39;application/json&#39; },
                    credentials: &#39;include&#39;,
                    body: JSON.stringify(rel)
                });
                
                if (response.ok) {
                    const result = await response.json();
                    if (result.success) successCount++;
                    else failCount++;
                } else {
                    failCount++;
                }
            } catch (error) {
                failCount++;
            }
        }
        
        if (successCount &gt; 0) {
            window.showNotification(`成功添加 ${successCount} 条关系${failCount &gt; 0 ? `，${failCount} 条失败` : &#39;&#39;}`, successCount === relations.length ? &#39;success&#39; : &#39;warning&#39;);
            document.getElementById(&#39;addRelationModal&#39;).close();
            document.getElementById(&#39;batchRelationInput&#39;).value = &#39;&#39;;
            document.getElementById(&#39;batchRelationPreview&#39;).classList.add(&#39;hidden&#39;);
            
            const data = await loadGraphData(graphId);
            if (data) {
                updatePageWithGraphData(data);
                renderGraphFromData();
            }
        } else {
            window.showNotification(&#39;批量添加失败&#39;, &#39;error&#39;);
        }
    };
    
    // ==================== 删除关系功能 ====================
    
    let deleteRelationData = []; // 存储关系数据用于删除
    
    // 打开删除关系模态框
    window.openDeleteRelationModal = function() {
        const edges = currentGraphData.edges || [];
        const nodes = currentGraphData.nodes || [];
        
        // 获取所有关系类型
        const types = [...new Set(edges.map(e =&gt; e.type || &#39;关联&#39;))];
        const typeSelect = document.getElementById(&#39;deleteRelationTypeFilter&#39;);
        typeSelect.innerHTML = &#39;<option value="">全部类型</option>&#39; + 
            types.map(t =&gt; `<option value="${t}">${t}</option>`).join(&#39;&#39;);
        
        // 构建关系列表数据
        deleteRelationData = edges.map(e =&gt; {
            const sourceNode = nodes.find(n =&gt; n.nodeId === e.sourceNodeId);
            const targetNode = nodes.find(n =&gt; n.nodeId === e.targetNodeId);
            return {
                ...e,
                sourceName: sourceNode?.name || &#39;未知&#39;,
                targetName: targetNode?.name || &#39;未知&#39;,
                selected: false
            };
        });
        
        document.getElementById(&#39;deleteRelationSearchInput&#39;).value = &#39;&#39;;
        renderDeleteRelationList();
        document.getElementById(&#39;deleteRelationModal&#39;).showModal();
    };
    
    // 渲染删除关系列表
    function renderDeleteRelationList() {
        const container = document.getElementById(&#39;deleteRelationList&#39;);
        const typeFilter = document.getElementById(&#39;deleteRelationTypeFilter&#39;).value;
        const searchInput = document.getElementById(&#39;deleteRelationSearchInput&#39;).value.toLowerCase();
        
        let filtered = deleteRelationData;
        
        if (typeFilter) {
            filtered = filtered.filter(r =&gt; (r.type || &#39;关联&#39;) === typeFilter);
        }
        
        if (searchInput) {
            filtered = filtered.filter(r =&gt; 
                r.sourceName.toLowerCase().includes(searchInput) ||
                r.targetName.toLowerCase().includes(searchInput)
            );
        }
        
        if (filtered.length === 0) {
            container.innerHTML = &#39;<div class="text-sm text-base-content/50 text-center py-4">没有找到匹配的关系</div>&#39;;
        } else {
            container.innerHTML = filtered.map((r, idx) =&gt; `
                <label class="flex items-center gap-2 p-2 hover:bg-base-200 rounded cursor-pointer">
                    <input type="checkbox" class="checkbox checkbox-sm checkbox-error" 
                           data-relation-idx="${deleteRelationData.indexOf(r)}"
                           ${r.selected ? &#39;checked&#39; : &#39;&#39;}
                           onchange="toggleDeleteRelation(${deleteRelationData.indexOf(r)})">
                    <span class="badge badge-sm badge-outline">${r.sourceName}</span>
                    <span class="text-xs text-base-content/50">→</span>
                    <span class="badge badge-xs badge-ghost">${r.type || &#39;关联&#39;}</span>
                    <span class="text-xs text-base-content/50">→</span>
                    <span class="badge badge-sm badge-outline">${r.targetName}</span>
                </label>
            `).join(&#39;&#39;);
        }
        
        updateDeleteRelationCount();
    }
    
    // 筛选删除关系
    window.filterDeleteRelations = function() {
        renderDeleteRelationList();
    };
    
    // 切换关系选中状态
    window.toggleDeleteRelation = function(idx) {
        deleteRelationData[idx].selected = !deleteRelationData[idx].selected;
        updateDeleteRelationCount();
    };
    
    // 全选
    window.selectAllDeleteRelations = function() {
        const typeFilter = document.getElementById(&#39;deleteRelationTypeFilter&#39;).value;
        const searchInput = document.getElementById(&#39;deleteRelationSearchInput&#39;).value.toLowerCase();
        
        deleteRelationData.forEach(r =&gt; {
            let match = true;
            if (typeFilter &amp;&amp; (r.type || &#39;关联&#39;) !== typeFilter) match = false;
            if (searchInput &amp;&amp; !r.sourceName.toLowerCase().includes(searchInput) &amp;&amp; !r.targetName.toLowerCase().includes(searchInput)) match = false;
            if (match) r.selected = true;
        });
        
        renderDeleteRelationList();
    };
    
    // 取消全选
    window.deselectAllDeleteRelations = function() {
        deleteRelationData.forEach(r =&gt; r.selected = false);
        renderDeleteRelationList();
    };
    
    // 更新选中数量
    function updateDeleteRelationCount() {
        const count = deleteRelationData.filter(r =&gt; r.selected).length;
        document.getElementById(&#39;selectedDeleteRelationCount&#39;).textContent = `已选择 ${count} 个关系`;
    }
    
    // 执行批量删除关系
    window.executeBatchDeleteRelations = async function() {
        const graphId = currentGraphData.id;
        if (!graphId) {
            window.showNotification(&#39;请先选择图谱&#39;, &#39;error&#39;);
            return;
        }
        
        const selected = deleteRelationData.filter(r =&gt; r.selected);
        if (selected.length === 0) {
            window.showNotification(&#39;请选择要删除的关系&#39;, &#39;warning&#39;);
            return;
        }
        
        if (!confirm(`确定要删除选中的 ${selected.length} 条关系吗？此操作不可恢复。`)) {
            return;
        }
        
        let successCount = 0;
        let failCount = 0;
        
        for (const rel of selected) {
            try {
                const response = await fetch(`/api/graph/${graphId}/relations/${rel.relationId || rel.edgeId}`, {
                    method: &#39;DELETE&#39;,
                    credentials: &#39;include&#39;
                });
                
                if (response.ok) {
                    successCount++;
                } else {
                    failCount++;
                }
            } catch (error) {
                failCount++;
            }
        }
        
        if (successCount &gt; 0) {
            window.showNotification(`成功删除 ${successCount} 条关系${failCount &gt; 0 ? `，${failCount} 条失败` : &#39;&#39;}`, successCount === selected.length ? &#39;success&#39; : &#39;warning&#39;);
            document.getElementById(&#39;deleteRelationModal&#39;).close();
            
            const data = await loadGraphData(graphId);
            if (data) {
                updatePageWithGraphData(data);
                renderGraphFromData();
            }
        } else {
            window.showNotification(&#39;删除失败&#39;, &#39;error&#39;);
        }
    };

    // ==================== 侧边栏折叠和拖拽调整功能 ====================
    
    let leftSidebarCollapsed = false;
    let isResizing = false;
    let startX = 0;
    let startWidth = 0;
    
    // 折叠/展开左侧栏
    window.toggleLeftSidebar = function() {
        const sidebar = document.getElementById(&#39;leftSidebar&#39;);
        const toggleBtn = document.getElementById(&#39;leftSidebarToggle&#39;);
        const toggleIcon = document.getElementById(&#39;leftToggleIcon&#39;);
        const resizeHandle = document.getElementById(&#39;leftResizeHandle&#39;);
        
        if (!sidebar) return;
        
        leftSidebarCollapsed = !leftSidebarCollapsed;
        
        if (leftSidebarCollapsed) {
            sidebar.style.width = &#39;0px&#39;;
            sidebar.style.minWidth = &#39;0&#39;;
            sidebar.style.overflow = &#39;hidden&#39;;
            toggleBtn.style.left = &#39;0px&#39;;
            resizeHandle.style.left = &#39;0px&#39;;
            resizeHandle.style.display = &#39;none&#39;;
            toggleIcon.setAttribute(&#39;data-icon&#39;, &#39;heroicons:chevron-right&#39;);
        } else {
            sidebar.style.width = &#39;320px&#39;;
            sidebar.style.minWidth = &#39;200px&#39;;
            sidebar.style.overflow = &#39;&#39;;
            toggleBtn.style.left = &#39;320px&#39;;
            resizeHandle.style.left = &#39;320px&#39;;
            resizeHandle.style.display = &#39;&#39;;
            toggleIcon.setAttribute(&#39;data-icon&#39;, &#39;heroicons:chevron-left&#39;);
        }
    };
    
    // 拖拽调整左侧栏宽度
    function initResizeHandle() {
        const resizeHandle = document.getElementById(&#39;leftResizeHandle&#39;);
        const sidebar = document.getElementById(&#39;leftSidebar&#39;);
        const toggleBtn = document.getElementById(&#39;leftSidebarToggle&#39;);
        
        if (!resizeHandle || !sidebar) return;
        
        resizeHandle.addEventListener(&#39;mousedown&#39;, function(e) {
            if (leftSidebarCollapsed) return;
            
            isResizing = true;
            startX = e.clientX;
            startWidth = sidebar.offsetWidth;
            
            resizeHandle.classList.add(&#39;active&#39;);
            document.body.style.cursor = &#39;col-resize&#39;;
            document.body.style.userSelect = &#39;none&#39;;
            
            e.preventDefault();
        });
        
        document.addEventListener(&#39;mousemove&#39;, function(e) {
            if (!isResizing) return;
            
            const diff = e.clientX - startX;
            let newWidth = startWidth + diff;
            
            // 限制宽度范围
            newWidth = Math.max(200, Math.min(450, newWidth));
            
            sidebar.style.width = newWidth + &#39;px&#39;;
            toggleBtn.style.left = newWidth + &#39;px&#39;;
            resizeHandle.style.left = newWidth + &#39;px&#39;;
        });
        
        document.addEventListener(&#39;mouseup&#39;, function() {
            if (!isResizing) return;
            
            isResizing = false;
            resizeHandle.classList.remove(&#39;active&#39;);
            document.body.style.cursor = &#39;&#39;;
            document.body.style.userSelect = &#39;&#39;;
        });
    }
    
    // 初始化拖拽功能
    document.addEventListener(&#39;DOMContentLoaded&#39;, initResizeHandle);
    if (document.readyState !== &#39;loading&#39;) {
        initResizeHandle();
    }
    
    // ==================== 右侧栏折叠和拖拽功能 ====================
    
    let rightSidebarCollapsed = false;
    let isResizingRight = false;
    let startXRight = 0;
    let startWidthRight = 0;
    const ACTION_PANEL_WIDTH = 64; // 右侧操作栏宽度
    
    // 折叠/展开右侧栏
    window.toggleRightSidebar = function() {
        const sidebar = document.getElementById(&#39;rightSidebar&#39;);
        const toggleBtn = document.getElementById(&#39;rightSidebarToggle&#39;);
        const toggleIcon = document.getElementById(&#39;rightToggleIcon&#39;);
        const resizeHandle = document.getElementById(&#39;rightResizeHandle&#39;);
        
        if (!sidebar) return;
        
        rightSidebarCollapsed = !rightSidebarCollapsed;
        
        if (rightSidebarCollapsed) {
            sidebar.style.width = &#39;0px&#39;;
            sidebar.style.minWidth = &#39;0&#39;;
            sidebar.style.overflow = &#39;hidden&#39;;
            toggleBtn.style.right = (ACTION_PANEL_WIDTH) + &#39;px&#39;;
            resizeHandle.style.right = (ACTION_PANEL_WIDTH) + &#39;px&#39;;
            resizeHandle.style.display = &#39;none&#39;;
            toggleIcon.setAttribute(&#39;data-icon&#39;, &#39;heroicons:chevron-left&#39;);
        } else {
            sidebar.style.width = &#39;300px&#39;;
            sidebar.style.minWidth = &#39;200px&#39;;
            sidebar.style.overflow = &#39;&#39;;
            toggleBtn.style.right = (300 + ACTION_PANEL_WIDTH) + &#39;px&#39;;
            resizeHandle.style.right = (300 + ACTION_PANEL_WIDTH + 16) + &#39;px&#39;;
            resizeHandle.style.display = &#39;&#39;;
            toggleIcon.setAttribute(&#39;data-icon&#39;, &#39;heroicons:chevron-right&#39;);
        }
    };
    
    // 拖拽调整右侧栏宽度
    function initRightResizeHandle() {
        const resizeHandle = document.getElementById(&#39;rightResizeHandle&#39;);
        const sidebar = document.getElementById(&#39;rightSidebar&#39;);
        const toggleBtn = document.getElementById(&#39;rightSidebarToggle&#39;);
        
        if (!resizeHandle || !sidebar) return;
        
        resizeHandle.addEventListener(&#39;mousedown&#39;, function(e) {
            if (rightSidebarCollapsed) return;
            
            isResizingRight = true;
            startXRight = e.clientX;
            startWidthRight = sidebar.offsetWidth;
            
            resizeHandle.classList.add(&#39;active&#39;);
            document.body.style.cursor = &#39;col-resize&#39;;
            document.body.style.userSelect = &#39;none&#39;;
            
            e.preventDefault();
        });
        
        document.addEventListener(&#39;mousemove&#39;, function(e) {
            if (!isResizingRight) return;
            
            const diff = startXRight - e.clientX; // 反向：向左拖动增加宽度
            let newWidth = startWidthRight + diff;
            
            // 限制宽度范围
            newWidth = Math.max(200, Math.min(450, newWidth));
            
            sidebar.style.width = newWidth + &#39;px&#39;;
            toggleBtn.style.right = (newWidth + ACTION_PANEL_WIDTH) + &#39;px&#39;;
            resizeHandle.style.right = (newWidth + ACTION_PANEL_WIDTH + 16) + &#39;px&#39;;
        });
        
        document.addEventListener(&#39;mouseup&#39;, function() {
            if (!isResizingRight) return;
            
            isResizingRight = false;
            resizeHandle.classList.remove(&#39;active&#39;);
            document.body.style.cursor = &#39;&#39;;
            document.body.style.userSelect = &#39;&#39;;
        });
    }
    
    // 初始化右侧拖拽功能
    document.addEventListener(&#39;DOMContentLoaded&#39;, initRightResizeHandle);
    if (document.readyState !== &#39;loading&#39;) {
        initRightResizeHandle();
    }
    
    // ==================== 节点详情显示功能 ====================
    
    // 更新节点详情面板
    window.updateNodeDetailPanel = function(node) {
        const container = document.getElementById(&#39;nodeDetailContent&#39;);
        if (!container || !node) return;
        
        // 从实际数据中获取完整节点信息（包括description）
        const nodeId = node.id || node.nodeId;
        const fullNodeData = (currentGraphData.nodes || []).find(n =&gt; n.nodeId === nodeId);
        const description = node.description || fullNodeData?.description || &#39;&#39;;
        
        // 获取该节点的关联节点
        const relatedNodes = getRelatedNodesFromData(nodeId);
        const connectionCount = getNodeConnectionCount(nodeId);
        
        // 获取节点颜色
        const nodeColor = getNodeColor(node.type || &#39;default&#39;);
        
        container.innerHTML = `
            <div class="space-y-4">
                <!-- 节点基本信息 -->
                <div class="flex items-start gap-3">
                    <div class="w-10 h-10 rounded-full flex items-center justify-center text-white font-semibold text-sm" style="background-color: ${nodeColor};">
                        ${(node.label || node.name || &#39;?&#39;).charAt(0).toUpperCase()}
                    </div>
                    <div class="flex-1 min-w-0">
                        <h4 class="font-semibold text-base-content truncate">${node.label || node.name || &#39;未命名&#39;}</h4>
                        <span class="badge badge-sm badge-ghost">${node.type || &#39;未分类&#39;}</span>
                    </div>
                </div>
                
                <!-- 统计信息 -->
                <div class="grid grid-cols-2 gap-2">
                    <div class="bg-base-100 rounded-lg p-3 text-center">
                        <div class="text-lg font-semibold text-primary">${connectionCount}</div>
                        <div class="text-xs text-base-content/60">连接数</div>
                    </div>
                    <div class="bg-base-100 rounded-lg p-3 text-center">
                        <div class="text-lg font-semibold text-secondary">${relatedNodes.length}</div>
                        <div class="text-xs text-base-content/60">相邻节点</div>
                    </div>
                </div>
                
                <!-- 节点简介 -->
                <div class="bg-base-100 rounded-lg p-3">
                    <div class="text-xs text-base-content/60 mb-1">简介</div>
                    <div class="text-sm text-base-content/80">${description || &#39;<span class="text-base-content/40">暂无简介</span>&#39;}</div>
                </div>
                
                <!-- 节点ID -->
                <div class="bg-base-100 rounded-lg p-3">
                    <div class="text-xs text-base-content/60 mb-1">节点ID</div>
                    <div class="text-sm font-mono text-base-content/80 break-all">${nodeId || &#39;-&#39;}</div>
                </div>
                
                <!-- 相邻节点列表 -->
                ${relatedNodes.length > 0 ? `
                <div>
                    <div class="text-xs text-base-content/60 mb-2">相邻节点</div>
                    <div class="space-y-1 max-h-40 overflow-y-auto">
                        ${relatedNodes.slice(0, 10).map(rn =&gt; `
                            <div class="flex items-center gap-2 p-2 bg-base-100 rounded hover:bg-base-300 cursor-pointer text-sm" onclick="showCenteredGraphView(&#39;${rn.id}&#39;)">
                                <div class="w-2 h-2 rounded-full" style="background-color: ${getNodeColor(rn.type || &#39;default&#39;)};"></div>
                                <span class="flex-1 truncate">${rn.name}</span>
                            </div>
                        `).join(&#39;&#39;)}
                        ${relatedNodes.length > 10 ? `<div class="text-xs text-center text-base-content/50 py-1">还有 ${relatedNodes.length - 10} 个节点...</div>` : &#39;&#39;}
                    </div>
                </div>
                ` : &#39;&#39;}
                
                <!-- 操作按钮 -->
                <div class="pt-2 border-t academic-border space-y-2">
                    <button class="btn btn-primary btn-sm w-full" onclick="showCenteredGraphView(&#39;${nodeId}&#39;)">
                        <span class="iconify" data-icon="heroicons:viewfinder-circle" data-width="16"></span>
                        以此节点为中心
                    </button>
                    <button class="btn btn-outline btn-sm w-full" onclick="openEditNodeModal(&#39;${nodeId}&#39;)">
                        <span class="iconify" data-icon="heroicons:pencil-square" data-width="16"></span>
                        编辑节点
                    </button>
                </div>
            </div>
        `;
    };
    
    // 清空节点详情面板
    window.clearNodeDetailPanel = function() {
        const container = document.getElementById(&#39;nodeDetailContent&#39;);
        if (!container) return;
        
        container.innerHTML = `
            <div class="text-center text-base-content/50 py-8">
                <span class="iconify mx-auto mb-3" data-icon="heroicons:cursor-arrow-rays" data-width="32"></span>
                <p class="text-sm">点击图谱中的节点</p>
                <p class="text-xs mt-1">查看详细信息</p>
            </div>
        `;
    };
    
    // ==================== 编辑节点功能 ====================
    
    // 打开编辑节点模态框
    window.openEditNodeModal = function(nodeId) {
        const nodes = currentGraphData.nodes || [];
        const node = nodes.find(n =&gt; n.nodeId === nodeId);
        
        if (!node) {
            window.showNotification(&#39;找不到该节点&#39;, &#39;error&#39;);
            return;
        }
        
        document.getElementById(&#39;editNodeId&#39;).value = nodeId;
        document.getElementById(&#39;editNodeName&#39;).value = node.name || &#39;&#39;;
        document.getElementById(&#39;editNodeType&#39;).value = node.type || &#39;&#39;;
        document.getElementById(&#39;editNodeDescription&#39;).value = node.description || &#39;&#39;;
        document.getElementById(&#39;editNodeImportance&#39;).value = node.importance || 5;
        
        document.getElementById(&#39;editNodeModal&#39;).showModal();
    };
    
    // 执行编辑节点
    window.executeEditNode = async function() {
        const graphId = currentGraphData.id;
        const nodeId = document.getElementById(&#39;editNodeId&#39;).value;
        
        if (!graphId || !nodeId) {
            window.showNotification(&#39;参数错误&#39;, &#39;error&#39;);
            return;
        }
        
        const name = document.getElementById(&#39;editNodeName&#39;).value.trim();
        const type = document.getElementById(&#39;editNodeType&#39;).value.trim();
        const description = document.getElementById(&#39;editNodeDescription&#39;).value.trim();
        const importance = parseInt(document.getElementById(&#39;editNodeImportance&#39;).value) || 5;
        
        if (!name) {
            window.showNotification(&#39;节点名称不能为空&#39;, &#39;warning&#39;);
            return;
        }
        
        try {
            const response = await fetch(`/api/graph/${graphId}/nodes/${nodeId}`, {
                method: &#39;PUT&#39;,
                headers: { &#39;Content-Type&#39;: &#39;application/json&#39; },
                credentials: &#39;include&#39;,
                body: JSON.stringify({ name, type, description, importance })
            });
            
            const result = await response.json();
            if (response.ok &amp;&amp; result.success) {
                window.showNotification(&#39;节点更新成功&#39;, &#39;success&#39;);
                document.getElementById(&#39;editNodeModal&#39;).close();
                
                // 重新加载图谱数据
                const data = await loadGraphData(graphId);
                if (data) {
                    updatePageWithGraphData(data);
                    renderGraphFromData();
                    
                    // 更新右侧详情面板
                    const updatedNode = data.nodes.find(n =&gt; n.nodeId === nodeId);
                    if (updatedNode &amp;&amp; window.updateNodeDetailPanel) {
                        window.updateNodeDetailPanel({
                            id: updatedNode.nodeId,
                            nodeId: updatedNode.nodeId,
                            name: updatedNode.name,
                            label: updatedNode.name,
                            type: updatedNode.type,
                            description: updatedNode.description
                        });
                    }
                }
            } else {
                window.showNotification(result.error || &#39;更新失败&#39;, &#39;error&#39;);
            }
        } catch (error) {
            window.showNotification(&#39;更新请求失败: &#39; + error.message, &#39;error&#39;);
        }
    };

})();
</script>
  

<script>
    setTimeout(() => {
      Holder.run({
        domain: "placehold.co"
      })
    }, 100)
  </script></body></html>'></iframe>
                    </div>
                  </div>

                </body>
                </html>
            
                </html>
            