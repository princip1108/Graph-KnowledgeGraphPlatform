# 热度推荐功能技术实现方案

本方案旨在后端实现基于 **Hacker News 重力算法** 的热度推荐功能。

## 1. 数据库变更 (Database Changes)

需要在 `knowledge_graph` 表中增加一个字段，用于存储计算好的热度分。

*   **表名**: `knowledge_graph`
*   **新增字段**: `hot_score`
*   **类型**: `DOUBLE` (默认值 0.0)
*   **索引**: 建议为该字段建立索引 `idx_hot_score` 以加速查询。

## 2. 核心算法实现 (Core Logic)

在 `GraphService` 或单独的 `RecommendationService` 中实现打分逻辑。

```java
public void updateAllHotScores() {
    List<KnowledgeGraph> allGraphs = graphRepository.findAll();
    for (KnowledgeGraph graph : allGraphs) {
        double score = calculateScore(graph);
        graph.setHotScore(score);
    }
    graphRepository.saveAll(allGraphs);
}

private double calculateScore(KnowledgeGraph graph) {
    // 1. 获取互动数据
    long views = graph.getViewCount() == null ? 0 : graph.getViewCount();
    long collects = graph.getCollectCount() == null ? 0 : graph.getCollectCount();
    long downloads = graph.getDownloadCount() == null ? 0 : graph.getDownloadCount();

    // 2. 计算互动总分 (权重: 收藏x5, 下载x3, 浏览x1)
    double interactions = views * 1.0 + collects * 5.0 + downloads * 3.0;

    // 3. 获取时间间隔 (小时)
    // 注意: 这里使用 UploadDate 可能不太准，如果有 LastModified 且包含互动更新时间会更好
    // 这里暂时使用 上传时间 作为基准 T
    long hoursSinceUpload = java.time.Duration.between(
        graph.getUploadDate().atStartOfDay(), 
        java.time.LocalDateTime.now()
    ).toHours();
    
    // 防止新发布的图谱分母过小，加 2 是标准做法
    double t = Math.max(0, hoursSinceUpload) + 2.0;
    double gravity = 1.8; // 重力因子

    // 4. 计算最终得分
    return (interactions - 1) / Math.pow(t, gravity);
}
```

## 3. 定时任务调度 (Scheduled Task)

为了避免每次请求都实时计算（太慢），采用 **定时离线计算** 的策略。

*   **组件**: 使用 Spring Boot 的 `@Scheduled` 注解。
*   **频率**: 每 1 小时执行一次 (或每 10 分钟，视数据量而定)。

```java
@Component
public class GraphHotScoreTask {
    
    @Autowired
    private GraphService graphService;

    // 每小时执行一次
    @Scheduled(fixedRate = 3600000)
    public void refreshHotScores() {
        log.info("开始更新图谱热度分...");
        graphService.updateAllHotScores();
        log.info("图谱热度分更新完成");
    }
}
```

## 4. 接口层改造 (API)

修改 `GraphController`，支持按 `hot_score` 排序。

*   **请求**: `GET /api/graph/public?sortBy=hot`
*   **后端处理**:
    ```java
    // GraphService.java
    private Pageable createPageable(int page, int size, String sortBy) {
        Sort sort;
        switch (sortBy) {
            case "hot" -> sort = Sort.by(Sort.Direction.DESC, "hotScore"); // 新增
            // ... 其他原有逻辑
        }
        return PageRequest.of(page, size, sort);
    }
    ```

## 5. 简单分类推荐实现

复用上述热度分。

*   **场景**: 在详情页显示“相关推荐”。
*   **逻辑**:
    1.  获取当前图谱的 `domain` (领域/分类)。
    2.  调用 Repository: `findTop10ByDomainAndIdNotOrderByHotScoreDesc(domain, currentId)`.
    3.  返回前 N 个结果。
