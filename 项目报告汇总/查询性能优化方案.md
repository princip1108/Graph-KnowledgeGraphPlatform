# 查询性能优化方案 (Query Optimization Plan)

**创建日期**: 2026-02-04
**状态**: 规划中 (Planned)

---

## 1. 现状分析 (Diagnostics)

经过对 `NodeController.java` 和 `RelationshipController.java` 的代码分析，我们确认了“API 数据传输冗余”的具体表现：

1.  **全量加载风险**: `getNodes` (`GET /api/graph/{id}/nodes`) 没有任何分页或分片逻辑。
    *   **后果**: 如果一个图谱有 5000 个节点，后端会一次性查询这 5000 个节点，并序列化成一个巨大的 JSON 数组传给前端。这会导致严重的网络阻塞和浏览器渲染卡顿。
2.  **字段冗余**: `NodeDto` 包含了 `description` (可能很长)、`outDegree` 等字段。在图谱概览（大图模式）下，前端渲染圆点只需要 `nodeId`, `name`, `type` (用于定色)，其他字段都是多余的。

---

## 2. 优化实施步骤

### 第一步：定义轻量级 DTO (Lite DTO)

我们需要创建专门用于“可视化渲染”的 DTO，只包含坐标计算和渲染必需的字段。

**文件**: `src/main/java/com/sdu/kgplatform/dto/LiteNodeDto.java`
```java
public class LiteNodeDto {
    private String nodeId;
    private String name;
    private String type;
    // 不包含 description, degrees 等重字段
}
```

**文件**: `src/main/java/com/sdu/kgplatform/dto/LiteRelationshipDto.java`
```java
public class LiteRelationshipDto {
    private String relationId;
    private String sourceNodeId; // 只传 ID，不传 Name
    private String targetNodeId;
    private String type;
}
```

### 第二步：Repository 层增加投影查询 (Projection)

修改 `NodeRepository` 和 `RelationshipRepository`，不查询整个 `@Node` 实体，而是只查询特定字段。

**修改**: `NodeRepository.java`
```java
@Query("MATCH (n:Entity) WHERE n.graphId = $graphId " +
       "RETURN n.nodeId as nodeId, n.name as name, n.type as type")
List<LiteNodeDto> findLiteNodesByGraphId(Integer graphId);
```

### 第三步：Controller 层增加按需加载接口

前端不需要一次性加载所有数据。我们可以实现**分片加载**或**按需加载**。

**新增接口**: `GET /api/graph/{id}/element-ids`
*   **用途**: 先只返回所有节点和关系的 ID 列表（非常小，几万个 ID 也就几百 KB）。
*   **前端逻辑**:
    1.  前端拿到 ID 列表。
    2.  根据视口（Viewport）位置或分页逻辑，分批去请求具体的节点详情 (`POST /api/graph/{id}/nodes/batch`，入参是 ID 列表)。
    3.  这样用户打开图谱时，能瞬间看到大概轮廓，细节逐步清晰。

### 第四步：后端 GZIP 压缩

确保 Spring Boot 开启了 GZIP 压缩。对于 JSON 文本，GZIP 压缩率通常能达到 80% 以上。

**配置**: `application.yaml`
```yaml
server:
  compression:
    enabled: true
    mime-types: application/json,application/xml
    min-response-size: 1024
```

---

## 3. 执行计划与沟通

**我建议我们分两阶段执行：**

1.  **阶段一 (快速见效)**:
    *   实现 `LiteNodeDto` 和 `LiteRelationshipDto`。
    *   新增 `/api/graph/{id}/visualization` 接口，专门返回这个轻量级数据包。
    *   前端修改：将详情页的初始请求改为调用这个新接口。
    *   **预期**: 数据传输量减少 60-70%。

2.  **阶段二 (彻底解决)**:
    *   实现 ID 列表 + 分批加载逻辑。
    *   这需要较大幅度的前端重构 (修改 D3.js/ECharts 的数据填充逻辑)。

**您希望先执行阶段一吗？** 这样改动最小，风险可控，且效果立竿见影。
