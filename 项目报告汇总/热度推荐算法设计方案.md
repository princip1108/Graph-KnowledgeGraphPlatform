# 热度推荐与分类推荐算法设计方案

针对您提出的“热度推荐”和“简单分类推荐”需求，为了避免“老图谱永远霸榜，新图谱无人问津”的马太效应，我建议放弃单纯的“按浏览量排序”，而是采用业界成熟的**加权互动分 + 时间衰减（重力算法）**。

## 1. 热度推荐算法设计 (The "Hot" Algorithm)

我们建议采用类似 **Hacker News** 或 **Reddit** 的排名算法逻辑，引入“时间衰减因子”。

### 核心公式 (Hacker News 重力算法改良版)

$$ \text{HotScore} = \frac{\text{Interactions} - 1}{(\text{TimeHours} + 2)^{G}} $$

### 参数详解

#### A. 互动热度 (Interactions)
单纯的浏览量（Views）价值最低，收藏（Collects）和下载（Downloads）代表了更深的用户认可。
我们定义互动分为加权总和：

$$ \text{Interactions} = (V \times W_v) + (C \times W_c) + (D \times W_d) $$

*   **$V$ (Views 浏览量)**: 权重 $W_v = 1$
*   **$C$ (Collections 收藏量)**: 权重 $W_c = 5$ (收藏代表强烈意向)
*   **$D$ (Downloads 下载量)**: 权重 $W_d = 3$ (下载代表实际使用)

*示例：一个图谱有 100 浏览，2 个收藏，1 次下载，其互动分为 $100 + 10 + 3 = 113$ 分。*

#### B. 时间衰减 (Time Decay)
这是算法的灵魂。$T$ 代表“图谱发布（或最后活跃）距离现在的小时数”。
分母 $(\text{TimeHours} + 2)^G$ 随着时间推移迅速增大，导致分数下降。

*   **$G$ (Gravity 重力因子)**:通常取 1.5 ~ 1.8。
    *   $G$ 越大，老内容掉下去得越快，榜单更新越频繁。
    *   $G$ 越小，榜单越稳定。
    *   **建议初值**: $1.8$

### 算法效果模拟
| 图谱 | 互动分 (P) | 发布时间 (T) | 计算: $P / (T+2)^{1.8}$ | 排名 | 结论 |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **A (老爆款)** | 1000 | 24小时前 | $1000 / 26^{1.8} \approx 1000 / 352 \approx \mathbf{2.8}$ | 2 | **老内容即使分高，也会慢慢沉底** |
| **B (新潜力)** | 50 | 2小时前 | $50 / 4^{1.8} \approx 50 / 12 \approx \mathbf{4.1}$ | 1 | **新发布的优质内容更容易上榜** |

---

## 2. 简单分类推荐 (Category Recommendation)

针对分类推荐，我们采用“**基于规则的召回 + 热度排序**”策略。

### 核心逻辑
1.  **确定用户兴趣**:
    *   如果用户已登录，获取其历史浏览最多的 Top 3 分类（如：医疗、金融）。
    *   如果用户未登录（或在图谱详情页），直接使用当前浏览图谱的分类。
2.  **内容召回 (Filter)**: 从数据库中筛选出属于该分类的所有图谱。
3.  **排序 (Rank)**: 复用上述的 **HotScore** 进行排序。

### 示例场景
用户正在看一个“金融风控图谱”（分类：金融）。
推荐逻辑：
1.  在数据库查找 `category = '金融'` 的其他图谱。
2.  排除掉当前正在看的这个。
3.  按 `HotScore` 降序排列取前 4 个展示。

---

## 3. 技术实现建议 (Implementation Notes)

为了保证性能，不要在每次用户请求时实时计算 $HotScore$。

1.  **定时任务 (Scheduled Task)**: 每 1 小时（或 10 分钟）运行一次批处理脚本。
2.  **计算与存储**: 计算所有图谱的 $HotScore$，并将其更新到数据库的 `hot_score` 字段（或 Redis 的 ZSET 中）。
3.  **查询**: 前端请求“热门”时，直接 `SELECT * FROM graphs ORDER BY hot_score DESC`，速度极快。
